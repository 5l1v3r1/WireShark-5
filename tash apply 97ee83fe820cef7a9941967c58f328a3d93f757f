[33mcommit 97ee83fe820cef7a9941967c58f328a3d93f757f[m
Merge: 6cbda18 630cf57 6f799f2
Author: tear94fall <tear94fall@naver.com>
Date:   Mon Sep 30 16:48:37 2019 +0900

    WIP on master: 6cbda18 Packet Data 부분 수정 및 기타 로직 변경

[1mdiff --cc Debug/MFCApplication1.exe[m
[1mindex 102bd12,102bd12,0000000..dab4e47[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc Debug/MFCApplication1.ilk[m
[1mindex 7b70443,7b70443,0000000..657ffa0[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc Debug/MFCApplication1.pdb[m
[1mindex 561e92a,561e92a,0000000..937cc0c[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc MFCApplication1/Debug/MFCApplication1.log[m
[1mindex f1f6a11,f1f6a11,0000000..1ebe68a[m
mode 100644,100644,000000..100644[m
[1m--- a/MFCApplication1/Debug/MFCApplication1.log[m
[1m+++ b/MFCApplication1/Debug/MFCApplication1.log[m
[36m@@@@ -1,6 -1,6 -1,0 +1,7 @@@@[m
[32m  +﻿  MFCApplication1Dlg.cpp[m
[32m  +C:\Users\limjoonsub\source\repos\MFCApplication1\MFCApplication1\MFCApplication1Dlg.cpp(165,30): warning C4244:  '=': 'double'에서 'int'(으)로 변환하면서 데이터가 손실될 수 있습니다.[m
[32m  +C:\Users\limjoonsub\source\repos\MFCApplication1\MFCApplication1\MFCApplication1Dlg.cpp(179,30): warning C4244:  '=': 'double'에서 'int'(으)로 변환하면서 데이터가 손실될 수 있습니다.[m
[32m  +C:\Users\limjoonsub\source\repos\MFCApplication1\MFCApplication1\MFCApplication1Dlg.cpp(474,18): warning C4018:  '<': signed 또는 unsigned가 일치하지 않습니다.[m
[32m  +C:\Users\limjoonsub\source\repos\MFCApplication1\MFCApplication1\MFCApplication1Dlg.cpp(536,17): warning C4018:  '<': signed 또는 unsigned가 일치하지 않습니다.[m
[32m+++C:\Users\limjoonsub\source\repos\MFCApplication1\MFCApplication1\MFCApplication1Dlg.cpp(791,84): warning C4552:  '+': 식의 결과가 사용되지 않습니다.[m
[32m  +  MFCApplication1.vcxproj -> C:\Users\limjoonsub\source\repos\MFCApplication1\Debug\MFCApplication1.exe[m
[1mdiff --cc MFCApplication1/Debug/MFCApplication1.obj[m
[1mindex c4e8ca5,c4e8ca5,0000000..ac078e0[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc MFCApplication1/Debug/MFCApplication1.tlog/CL.command.1.tlog[m
[1mindex d9bf135,d9bf135,0000000..f3debba[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc MFCApplication1/Debug/MFCApplication1.tlog/CL.read.1.tlog[m
[1mindex 429b25c,429b25c,0000000..c9c9cfd[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc MFCApplication1/Debug/MFCApplication1.tlog/CL.write.1.tlog[m
[1mindex d9bfa3e,d9bfa3e,0000000..0fa1a1c[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc MFCApplication1/Debug/MFCApplication1Dlg.obj[m
[1mindex 1ade660,1ade660,0000000..56ad3db[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc MFCApplication1/Debug/vc142.idb[m
[1mindex 58679c9,58679c9,0000000..1299713[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc MFCApplication1/Debug/vc142.pdb[m
[1mindex d27fd09,d27fd09,0000000..a5a240a[m
mode 100644,100644,000000..100644[m
Binary files differ
[1mdiff --cc MFCApplication1/MFCApplication1Dlg.cpp[m
[1mindex ef9f4b3,ef9f4b3,0000000..61d4d0c[m
mode 100644,100644,000000..100644[m
[1m--- a/MFCApplication1/MFCApplication1Dlg.cpp[m
[1m+++ b/MFCApplication1/MFCApplication1Dlg.cpp[m
[36m@@@@ -1,1017 -1,1017 -1,0 +1,1422 @@@@[m
[32m  +﻿[m
[32m  +// MFCApplication1Dlg.cpp: 구현 파일[m
[32m  +//[m
[32m  +[m
[32m  +#include "pch.h"[m
[32m  +#include "framework.h"[m
[32m  +#include "MFCApplication1.h"[m
[32m  +#include "MFCApplication1Dlg.h"[m
[32m  +#include "afxdialogex.h"[m
[32m  +#include "Resource.h"[m
[32m  +#include "NetworkInterfaceDlg.h"[m
[32m  +[m
[32m  +#include <thread>[m
[32m  +#include <sstream>[m
[32m  +#include <pcap.h>[m
[32m  +#include <map>[m
[32m  +#include <vector>[m
[32m  +#include <sstream>[m
[32m  +#include <iomanip>[m
[32m  +[m
[32m  +[m
[32m  +#ifdef _DEBUG[m
[32m  +#define new DEBUG_NEW[m
[32m  +#endif[m
[32m  +[m
[32m  +// 응용 프로그램 정보에 사용되는 CAboutDlg 대화 상자입니다.[m
[32m  +void packet_handler(u_char* param, const struct pcap_pkthdr* header, const u_char* pkt_data);[m
[32m  +std::string GetCurrentTimeStr(void);[m
[32m  +[m
[32m  +class CAboutDlg : public CDialogEx[m
[32m  +{[m
[32m  +public:[m
[32m  +	CAboutDlg();[m
[32m  +[m
[32m  +// 대화 상자 데이터입니다.[m
[32m  +#ifdef AFX_DESIGN_TIME[m
[32m  +	enum { IDD = IDD_ABOUTBOX };[m
[32m  +#endif[m
[32m  +[m
[32m  +	protected:[m
[32m  +	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 지원입니다.[m
[32m  +[m
[32m  +// 구현입니다.[m
[32m  +protected:[m
[32m  +	DECLARE_MESSAGE_MAP()[m
[32m  +};[m
[32m  +[m
[32m  +CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)[m
[32m  +{[m
[32m  +}[m
[32m  +[m
[32m  +void CAboutDlg::DoDataExchange(CDataExchange* pDX)[m
[32m  +{[m
[32m  +	CDialogEx::DoDataExchange(pDX);[m
[32m  +}[m
[32m  +[m
[32m  +BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)[m
[32m  +END_MESSAGE_MAP()[m
[32m  +[m
[32m  +[m
[32m  +// CMFCApplication1Dlg 대화 상자[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +CMFCApplication1Dlg::CMFCApplication1Dlg(CWnd* pParent /*=nullptr*/)[m
[32m  +	: CDialogEx(IDD_MFCAPPLICATION1_DIALOG, pParent)[m
[32m  +{[m
[32m  +	m_hIcon = AfxGetApp()->LoadIcon(IDI_ICON1);[m
[32m  +}[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::DoDataExchange(CDataExchange* pDX)[m
[32m  +{[m
[32m  +	CDialogEx::DoDataExchange(pDX);[m
[32m  +	DDX_Control(pDX, IDC_LIST2, m_ListCtrl);[m
[32m  +	DDX_Control(pDX, IDC_BUTTON3, pause_button);[m
[32m  +	DDX_Control(pDX, IDC_TREE1, PacketDataCtrl);[m
[32m  +	DDX_Control(pDX, IDC_LIST1, PacketDumpList);[m
[32m  +	DDX_Control(pDX, IDC_EDIT1, m_FilterEditCtrl);[m
[32m  +}[m
[32m  +[m
[32m  +BEGIN_MESSAGE_MAP(CMFCApplication1Dlg, CDialogEx)[m
[32m  +	ON_WM_SYSCOMMAND()[m
[32m  +	ON_WM_PAINT()[m
[32m  +	ON_WM_QUERYDRAGICON()[m
[32m  +	ON_BN_CLICKED(IDC_BUTTON1, &CMFCApplication1Dlg::OnBnClickedButton1)[m
[32m  +	ON_BN_CLICKED(IDC_BUTTON2, &CMFCApplication1Dlg::OnBnClickedButton2)[m
[32m  +	ON_BN_CLICKED(IDC_BUTTON3, &CMFCApplication1Dlg::OnBnClickedButton3)[m
[32m  +	ON_NOTIFY(NM_CUSTOMDRAW, IDC_LIST2, OnCustomdrawList)[m
[32m  +	ON_NOTIFY(NM_DBLCLK, IDC_LIST2, &CMFCApplication1Dlg::OnNMDblclkList2)[m
[32m  +	ON_NOTIFY(HDN_ITEMCLICK, 0, &CMFCApplication1Dlg::OnHdnItemclick)[m
[32m  +//	ON_NOTIFY(NM_CUSTOMDRAW, IDC_LIST1, &CMFCApplication1Dlg::OnNMCustomdrawList1)[m
[32m  +END_MESSAGE_MAP()[m
[32m  +[m
[32m  +[m
[32m  +// CMFCApplication1Dlg 메시지 처리기[m
[32m  +[m
[32m  +BOOL CMFCApplication1Dlg::OnInitDialog()[m
[32m  +{[m
[32m  +	netInterfaceDlg.DoModal();[m
[32m  +	bool cancelButtonClickedChecker = netInterfaceDlg.CancelButtonClickedFunction();[m
[32m  +[m
[32m  +	if (cancelButtonClickedChecker) {[m
[32m  +		::PostQuitMessage(WM_QUIT);[m
[32m  +		netInterfaceDlg.EndDialog(IDOK);[m
[32m  +		//DestroyWindow();[m
[32m  +	}[m
[32m  +[m
[32m  +	CDialogEx::OnInitDialog();[m
[32m  +[m
[32m  +	// 시스템 메뉴에 "정보..." 메뉴 항목을 추가합니다.[m
[32m  +[m
[32m  +	// IDM_ABOUTBOX는 시스템 명령 범위에 있어야 합니다.[m
[32m  +	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);[m
[32m  +	ASSERT(IDM_ABOUTBOX < 0xF000);[m
[32m  +[m
[32m  +	CMenu* pSysMenu = GetSystemMenu(FALSE);[m
[32m  +	if (pSysMenu != nullptr)[m
[32m  +	{[m
[32m  +		BOOL bNameValid;[m
[32m  +		CString strAboutMenu;[m
[32m  +		bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);[m
[32m  +		ASSERT(bNameValid);[m
[32m  +		if (!strAboutMenu.IsEmpty())[m
[32m  +		{[m
[32m  +			pSysMenu->AppendMenu(MF_SEPARATOR);[m
[32m  +			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);[m
[32m  +		}[m
[32m  +	}[m
[32m  +[m
[32m  +	// 이 대화 상자의 아이콘을 설정합니다.  응용 프로그램의 주 창이 대화 상자가 아닐 경우에는[m
[32m  +	//  프레임워크가 이 작업을 자동으로 수행합니다.[m
[32m  +	SetIcon(m_hIcon, TRUE);			// 큰 아이콘을 설정합니다.[m
[32m  +	SetIcon(m_hIcon, FALSE);		// 작은 아이콘을 설정합니다.[m
[32m  +[m
[32m  +	// TODO: 여기에 추가 초기화 작업을 추가합니다.[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +	CButton* pButton = (CButton*)GetDlgItem(IDC_BUTTON2);[m
[32m  +	pButton->EnableWindow(FALSE);[m
[32m  +[m
[32m  +	CButton* pButton3 = (CButton*)GetDlgItem(IDC_BUTTON3);[m
[32m  +	pButton3->EnableWindow(FALSE);[m
[32m  +[m
[32m  +	SetWindowText(_T("Wire Dolphin "));[m
[32m  +[m
[32m  +	m_FilterEditCtrl.SetWindowTextW(L"Enter filters...");[m
[32m  +[m
[32m  +	CRect rt;[m
[32m  +	m_ListCtrl.GetWindowRect(&rt);[m
[32m  +	m_ListCtrl.SetExtendedStyle(LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT);[m
[32m  +	LV_COLUMN add_column;[m
[32m  +	// 컬럼 속성을 지정한다. 텍스트 형식을 사용하고 폭을 명시하겠다고 설정한다.[m
[32m  +[m
[32m  +	add_column.mask = LVCF_TEXT | LVCF_WIDTH;[m
[32m  +[m
[32m  +	LPWSTR column_name[9] = { L"No",L"Time", L"Source", L"Destination", L"Protocol", L"Length", L"Info" ,L"Dump Data" };[m
[32m  +	int count = 0;[m
[32m  +	double column_width[9] = { 0.1, 0.17, 0.15, 0.15, 0.075, 0.075, 0.28, 0 };[m
[32m  +[m
[32m  +	for (int i = 0; i < 8; i++) {[m
[32m  +		add_column.pszText = column_name[i];[m
[32m  +		add_column.cx = rt.Width() * column_width[i];[m
[32m  +		m_ListCtrl.InsertColumn(i, &add_column);[m
[32m  +	}[m
[32m  +[m
[32m  +	PacketDumpList.GetWindowRect(&rt);[m
[32m  +	PacketDumpList.SetExtendedStyle(LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT);[m
[32m  +	// 컬럼 속성을 지정한다. 텍스트 형식을 사용하고 폭을 명시하겠다고 설정한다.[m
[32m  +[m
[32m  +	add_column.mask = LVCF_TEXT | LVCF_WIDTH;[m
[32m  +	LPWSTR packet_dump_header[4] = { L"Seq",L"Hex 1",L"HEX 2", L"ASCII" };[m
[32m  +	double pakcet_dump_header_width[4] = { 0.1,0.27,0.27,0.3 };[m
[32m  +[m
[32m  +	for (int i = 0; i < 4; i++) {[m
[32m  +		add_column.pszText = packet_dump_header[i];[m
[32m  +		add_column.cx = rt.Width() * pakcet_dump_header_width[i];[m
[32m  +		PacketDumpList.InsertColumn(i, &add_column);[m
[32m  +	}[m
[32m  +	// 패킷의 갯수 카운트[m
[32m  +	ChangeStaticText(packet_cnt, tcp_pkt_cnt, udp_pkt_cnt, arp_pkt_cnt, icmp_pkt_cnt);[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +	return TRUE;  // 포커스를 컨트롤에 설정하지 않으면 TRUE를 반환합니다.[m
[32m  +}[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::OnSysCommand(UINT nID, LPARAM lParam)[m
[32m  +{[m
[32m  +	if ((nID & 0xFFF0) == IDM_ABOUTBOX)[m
[32m  +	{[m
[32m  +		CAboutDlg dlgAbout;[m
[32m  +		dlgAbout.DoModal();[m
[32m  +	}[m
[32m  +	else[m
[32m  +	{[m
[32m  +		CDialogEx::OnSysCommand(nID, lParam);[m
[32m  +	}[m
[32m  +}[m
[32m  +[m
[32m  +// 대화 상자에 최소화 단추를 추가할 경우 아이콘을 그리려면[m
[32m  +//  아래 코드가 필요합니다.  문서/뷰 모델을 사용하는 MFC 애플리케이션의 경우에는[m
[32m  +//  프레임워크에서 이 작업을 자동으로 수행합니다.[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::OnPaint()[m
[32m  +{[m
[32m  +	if (IsIconic())[m
[32m  +	{[m
[32m  +		CPaintDC dc(this); // 그리기를 위한 디바이스 컨텍스트입니다.[m
[32m  +[m
[32m  +		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);[m
[32m  +[m
[32m  +		// 클라이언트 사각형에서 아이콘을 가운데에 맞춥니다.[m
[32m  +		int cxIcon = GetSystemMetrics(SM_CXICON);[m
[32m  +		int cyIcon = GetSystemMetrics(SM_CYICON);[m
[32m  +		CRect rect;[m
[32m  +		GetClientRect(&rect);[m
[32m  +		int x = (rect.Width() - cxIcon + 1) / 2;[m
[32m  +		int y = (rect.Height() - cyIcon + 1) / 2;[m
[32m  +[m
[32m  +		// 아이콘을 그립니다.[m
[32m  +		dc.DrawIcon(x, y, m_hIcon);[m
[32m  +	}[m
[32m  +	else[m
[32m  +	{[m
[32m  +		CDialogEx::OnPaint();[m
[32m  +	}[m
[32m  +}[m
[32m  +[m
[32m  +// 사용자가 최소화된 창을 끄는 동안에 커서가 표시되도록 시스템에서[m
[32m  +//  이 함수를 호출합니다.[m
[32m  +HCURSOR CMFCApplication1Dlg::OnQueryDragIcon()[m
[32m  +{[m
[32m  +	return static_cast<HCURSOR>(m_hIcon);[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::OnBnClickedButton1()[m
[32m  +{[m
[32m  +	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.[m
[32m  +	if (m_pThread == NULL) {[m
[32m  +		m_pThread = AfxBeginThread(ThreadFunctionFirstTest, this);[m
[32m  +		//AfxMessageBox(_T("캡처를 시작합니다"));[m
[32m  +		CButton* pButton = (CButton*)GetDlgItem(IDC_BUTTON1);[m
[32m  +		pButton->EnableWindow(FALSE);[m
[32m  +[m
[32m  +		CButton* pButton2 = (CButton*)GetDlgItem(IDC_BUTTON2);[m
[32m  +		pButton2->EnableWindow(TRUE);[m
[32m  +[m
[32m  +		CButton* pButton3 = (CButton*)GetDlgItem(IDC_BUTTON3);[m
[32m  +		pButton3->EnableWindow(TRUE);[m
[32m  +[m
[32m  +		if (m_pThread == NULL) {[m
[32m  +			AfxMessageBox(_T("Error!!!"));[m
[32m  +		}[m
[32m  +[m
[32m  +		m_pThread->m_bAutoDelete = FALSE;[m
[32m  +		m_ThreadWorkType = RUNNING;[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +	}[m
[32m  +	else {[m
[32m  +		if (m_ThreadWorkType == RUNNING || m_ThreadWorkType == PAUSE) {[m
[32m  +			//m_pThread->ResumeThread();[m
[32m  +			//m_ThreadWorkType = RUNNING;[m
[32m  +		}[m
[32m  +	}[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +UINT CMFCApplication1Dlg::ThreadFunctionFirstTest(LPVOID _mothod) {[m
[32m  +	CMFCApplication1Dlg* pDlg = (CMFCApplication1Dlg*)AfxGetApp()->m_pMainWnd;[m
[32m  +	pcap_if_t* alldevs;[m
[32m  +	pcap_if_t* d;[m
[32m  +	int inum;[m
[32m  +	int i = 0;[m
[32m  +	pcap_t* adhandle;[m
[32m  +	char errbuf[PCAP_ERRBUF_SIZE];[m
[32m  +[m
[32m  +	const char* filter = "tcp or udp or arp or icmp";[m
[32m  +	//const char* filter = "arp or tcp or udp or icmp";[m
[32m  +	struct bpf_program fcode;[m
[32m  +	bpf_u_int32 NetMask;[m
[32m  +[m
[32m  +	if (pcap_findalldevs(&alldevs, errbuf) == -1) {[m
[32m  +		fprintf(stderr, "Error in pcap_findalldevs: %s\n", errbuf);[m
[32m  +		exit(1);[m
[32m  +	}[m
[32m  +[m
[32m  +	for (d = alldevs; d; d = d->next) {[m
[32m  +		printf("%d. %s", ++i, d->name);[m
[32m  +[m
[32m  +		if (d->description) {[m
[32m  +			printf(" (%s)\n", d->description);[m
[32m  +		}[m
[32m  +		else {[m
[32m  +			printf(" (No description available)\n");[m
[32m  +		}[m
[32m  +	}[m
[32m  +[m
[32m  +	if (i == 0) {[m
[32m  +		printf("\nNo interfaces found! Make sure WinPcap is installed.\n");[m
[32m  +		return -1;[m
[32m  +	}[m
[32m  +[m
[32m  +	printf("Enter the interface number (1-%d):", i);[m
[32m  +	//scanf("%d", &inum);[m
[32m  +	inum = pDlg->netInterfaceDlg.m_nSelectedIndex + 1;[m
[31m-- 	pDlg->m_strSelectedNetworkInterface = pDlg->netInterfaceDlg.m_strSelectedValue;[m
[32m+++	pDlg->m_strSelectedNetworkInterface = pDlg->netInterfaceDlg.InterfaceDescription;[m
[32m  +[m
[32m  +	pDlg->SetDlgItemText(IDC_STATIC_NET,L"Interface: "+pDlg->m_strSelectedNetworkInterface);[m
[32m  +[m
[32m  +	if (inum < 1 || inum > i) {[m
[32m  +		printf("\nInterface number out of range.\n");[m
[32m  +		pcap_freealldevs(alldevs);[m
[32m  +		return -1;[m
[32m  +	}[m
[32m  +[m
[32m  +	for (d = alldevs, i = 0; i < inum - 1; d = d->next, i++);[m
[32m  +[m
[32m  +[m
[32m  +	if ((adhandle = pcap_open_live(d->name, 65536, 1, 1000, errbuf)) == NULL) {[m
[32m  +		fprintf(stderr, "\nUnable to open the adapter. %s is not supported by WinPcap\n", d->name);[m
[32m  +		pcap_freealldevs(alldevs);[m
[32m  +		return -1;[m
[32m  +	}[m
[32m  +[m
[32m  +	printf("\nlistening on %s...\n", d->description);[m
[32m  +[m
[32m  +	NetMask = 0xffffff;[m
[32m  +	if (pcap_compile(adhandle, &fcode, filter, 1, NetMask) < 0) {[m
[32m  +		fprintf(stderr, "\nError compiling filter: wrong syntax.\n");[m
[32m  +		pcap_close(adhandle);[m
[32m  +		return -3;[m
[32m  +	}[m
[32m  +[m
[32m  +	if (pcap_setfilter(adhandle, &fcode) < 0) {[m
[32m  +		fprintf(stderr, "\nError setting the filter\n");[m
[32m  +		pcap_close(adhandle);[m
[32m  +		return -4;[m
[32m  +	}[m
[32m  +[m
[32m  +	pcap_freealldevs(alldevs);[m
[32m  +	pcap_loop(adhandle, 0, packet_handler, NULL);[m
[32m  +[m
[32m  +	return 0;[m
[32m  +}[m
[32m  +[m
[32m  +void packet_handler(u_char* param, const struct pcap_pkthdr* header, const u_char* pkt_data) {[m
[32m  +	CMFCApplication1Dlg* pDlg = (CMFCApplication1Dlg*)AfxGetApp()->m_pMainWnd;[m
[32m  +	int i;[m
[32m  +	ip_header* ih;[m
[32m  +	udp_header* uh;[m
[32m  +	tcp_header* th;[m
[32m  +	icmp_header* icmp_hdr;[m
[32m  +	arp_header* arp_hdr = NULL;[m
[32m  +	u_int ip_len;[m
[32m  +	ether_header* ethhdr;[m
[32m  +[m
[32m  +	ethhdr = (ether_header*)pkt_data;[m
[32m  +[m
[32m  +	ih = (ip_header*)(pkt_data + 14);[m
[32m  +	ip_len = (ih->ver_ihl & 0xf) * 4;[m
[32m  +[m
[32m  +	int size = sizeof(pkt_data);[m
[32m  +[m
[32m  +	if (ntohs(ethhdr->frame_type) == 0x0800) {[m
[32m  +		if (ih->proto == IPPROTO_TCP) {[m
[32m  +			// TCP[m
[32m  +			th = (tcp_header*)((u_char*)ih + ip_len);[m
[32m  +[m
[32m  +			CString source_ip = pDlg->GetIPAddr(ih->saddr);[m
[32m  +			CString destionation_ip = pDlg->GetIPAddr(ih->daddr);[m
[32m  +[m
[32m  +			int column_count = pDlg->m_ListCtrl.GetItemCount();[m
[32m  +[m
[32m  +			CString column_count_str;[m
[32m  +			column_count_str.Format(_T("%d"), column_count + 1);[m
[32m  +			pDlg->m_ListCtrl.InsertItem(column_count, column_count_str);[m
[32m  +[m
[32m  +[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 1, LVIF_TEXT, CString(GetCurrentTimeStr().c_str()), NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 2, LVIF_TEXT, source_ip, NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 3, LVIF_TEXT, destionation_ip, NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 4, LVIF_TEXT, _T("TCP"), NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 5, LVIF_TEXT, (CString)(std::to_string(header->caplen).c_str()), NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 6, LVIF_TEXT, (CString)(std::to_string(htons(th->sport)).c_str())[m
[32m  +				+ " -> " +[m
[32m  +				(CString)(std::to_string(ntohs(th->dport)).c_str())[m
[32m  +				, NULL, NULL, NULL, NULL);[m
[32m  +[m
[32m  +			++pDlg->tcp_pkt_cnt;[m
[32m  +			++pDlg->packet_cnt;[m
[32m  +[m
[32m  +			pDlg->ChangeStaticText(pDlg->packet_cnt, pDlg->tcp_pkt_cnt, pDlg->udp_pkt_cnt, pDlg->arp_pkt_cnt, pDlg->icmp_pkt_cnt);[m
[32m  +		}[m
[32m  +		else if (ih->proto == 4) {[m
[32m  +			printf("IP\n");[m
[32m  +		}[m
[32m  +		else if (ih->proto == IPPROTO_UDP) {[m
[32m  +			// UDP[m
[32m  +[m
[32m  +			uh = (udp_header*)((u_char*)ih + ip_len);[m
[32m  +[m
[32m  +			CString source_ip = pDlg->GetIPAddr(ih->saddr);[m
[32m  +			CString destionation_ip = pDlg->GetIPAddr(ih->daddr);[m
[32m  +[m
[32m  +			int column_count = pDlg->m_ListCtrl.GetItemCount();[m
[32m  +[m
[32m  +			CString column_count_str;[m
[32m  +			column_count_str.Format(_T("%d"), column_count + 1);[m
[32m  +			pDlg->m_ListCtrl.InsertItem(column_count, column_count_str);[m
[32m  +[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 1, LVIF_TEXT, CString(GetCurrentTimeStr().c_str()), NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 2, LVIF_TEXT, source_ip, NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 3, LVIF_TEXT, destionation_ip, NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 4, LVIF_TEXT, _T("UDP"), NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 5, LVIF_TEXT, (CString)(std::to_string(header->caplen).c_str()), NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 6, LVIF_TEXT, (CString)(std::to_string(htons(uh->sport)).c_str())[m
[32m  +				+ " -> " +[m
[32m  +				(CString)(std::to_string(ntohs(uh->dport)).c_str())[m
[32m  +				, NULL, NULL, NULL, NULL);[m
[32m  +[m
[32m  +			++pDlg->udp_pkt_cnt;[m
[32m  +			++pDlg->packet_cnt;[m
[32m  +			pDlg->ChangeStaticText(pDlg->packet_cnt, pDlg->tcp_pkt_cnt, pDlg->udp_pkt_cnt, pDlg->arp_pkt_cnt, pDlg->icmp_pkt_cnt);[m
[32m  +		}[m
[32m  +		else if (ih->proto == IPPROTO_ICMP) {[m
[32m  +			// ICMP[m
[32m  +[m
[32m  +			icmp_hdr = (icmp_header*)(ih + ip_len);[m
[32m  +[m
[32m  +			CString source_ip = pDlg->GetIPAddr(ih->saddr);[m
[32m  +			CString destionation_ip = pDlg->GetIPAddr(ih->daddr);[m
[32m  +[m
[32m  +			int column_count = pDlg->m_ListCtrl.GetItemCount();[m
[32m  +[m
[32m  +			CString column_count_str;[m
[32m  +			column_count_str.Format(_T("%d"), column_count + 1);[m
[32m  +			pDlg->m_ListCtrl.InsertItem(column_count, column_count_str);[m
[32m  +[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 1, LVIF_TEXT, CString(GetCurrentTimeStr().c_str()), NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 2, LVIF_TEXT, source_ip, NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 3, LVIF_TEXT, destionation_ip, NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 4, LVIF_TEXT, _T("ICMP"), NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 5, LVIF_TEXT, (CString)(std::to_string(header->caplen).c_str()), NULL, NULL, NULL, NULL);[m
[32m  +			pDlg->m_ListCtrl.SetItem(column_count, 6, LVIF_TEXT, (CString)(std::to_string(icmp_hdr->code).c_str())[m
[32m  +				, NULL, NULL, NULL, NULL);[m
[32m  +[m
[32m  +[m
[32m  +			++pDlg->icmp_pkt_cnt;[m
[32m  +			++pDlg->packet_cnt;[m
[32m  +			pDlg->ChangeStaticText(pDlg->packet_cnt, pDlg->tcp_pkt_cnt, pDlg->udp_pkt_cnt, pDlg->arp_pkt_cnt, pDlg->icmp_pkt_cnt);[m
[32m  +		}[m
[32m  +		else {[m
[32m  +			printf("Unknown Protocol\n");[m
[32m  +			unsigned char temp = ih->proto;[m
[32m  +[m
[32m  +		}[m
[32m  +[m
[32m  +		pDlg->ChangeStaticText(pDlg->packet_cnt, pDlg->tcp_pkt_cnt, pDlg->udp_pkt_cnt, pDlg->arp_pkt_cnt, pDlg->icmp_pkt_cnt);[m
[32m  +[m
[32m  +		int nCount = pDlg->m_ListCtrl.GetItemCount();[m
[32m  +		pDlg->m_ListCtrl.EnsureVisible(nCount - 1, FALSE);[m
[32m  +[m
[32m  +[m
[32m  +		std::string packet_dump_data;[m
[32m  +[m
[32m  +		for (i = 1; (i < header->caplen + 1); i++) {[m
[32m  +			char* temp = NULL;[m
[32m  +[m
[32m  +			int temp2 = pkt_data[i - 1];[m
[32m  +[m
[32m  +			std::stringstream stream;[m
[32m  +			stream << std::hex << temp2;[m
[32m  +			packet_dump_data += stream.str() + " ";[m
[32m  +[m
[32m  +		}[m
[32m  +	}[m
[32m  +	else if (ntohs(ethhdr->frame_type) == 0x0806) {[m
[32m  +[m
[32m  +	// ARP[m
[32m  +	arp_hdr = (struct arp_header*)(pkt_data + 14);[m
[32m  +[m
[32m  +	CString source_ip = pDlg->GetIPAddr(ih->saddr);[m
[32m  +	CString destionation_ip = pDlg->GetIPAddr(ih->daddr);[m
[32m  +[m
[32m  +	int column_count = pDlg->m_ListCtrl.GetItemCount();[m
[32m  +[m
[32m  +	CString column_count_str;[m
[32m  +	column_count_str.Format(_T("%d"), column_count + 1);[m
[32m  +	pDlg->m_ListCtrl.InsertItem(column_count, column_count_str);[m
[32m  +[m
[32m  +	char soure_hw_addr[4];[m
[32m  +	char target_hw_addr[4];[m
[32m  +[m
[32m  +	CString sender_hw_addr, target_hw_adr;[m
[32m  +	for (int i = 0; i < 5; i++) {[m
[32m  +		sprintf(soure_hw_addr, "%02x:", arp_hdr->sha[i]);[m
[32m  +		sender_hw_addr += soure_hw_addr;[m
[32m  +[m
[32m  +		sprintf(target_hw_addr, "%02x:", arp_hdr->tha[i]);[m
[32m  +		target_hw_adr += target_hw_addr;[m
[32m  +	}[m
[32m  +[m
[32m  +	sprintf(soure_hw_addr, "%02x", arp_hdr->sha[5]);[m
[32m  +	sender_hw_addr += soure_hw_addr;[m
[32m  +[m
[32m  +	sprintf(target_hw_addr, "%02x", arp_hdr->tha[5]);[m
[32m  +	target_hw_adr += target_hw_addr;[m
[32m  +[m
[32m  +[m
[32m  +	pDlg->m_ListCtrl.SetItem(column_count, 1, LVIF_TEXT, CString(GetCurrentTimeStr().c_str()), NULL, NULL, NULL, NULL);[m
[32m  +	pDlg->m_ListCtrl.SetItem(column_count, 2, LVIF_TEXT, source_ip, NULL, NULL, NULL, NULL);[m
[32m  +	pDlg->m_ListCtrl.SetItem(column_count, 3, LVIF_TEXT, destionation_ip, NULL, NULL, NULL, NULL);[m
[32m  +	pDlg->m_ListCtrl.SetItem(column_count, 4, LVIF_TEXT, _T("ARP"), NULL, NULL, NULL, NULL);[m
[32m  +	pDlg->m_ListCtrl.SetItem(column_count, 5, LVIF_TEXT, (CString)(std::to_string(header->caplen).c_str()), NULL, NULL, NULL, NULL);[m
[32m  +	pDlg->m_ListCtrl.SetItem(column_count, 6, LVIF_TEXT,[m
[32m  +		sender_hw_addr + L" -> " + target_hw_adr[m
[32m  +		, NULL, NULL, NULL, NULL);[m
[32m  +[m
[32m  +[m
[32m  +	++pDlg->arp_pkt_cnt;[m
[32m  +	++pDlg->packet_cnt;[m
[32m  +	pDlg->ChangeStaticText(pDlg->packet_cnt, pDlg->tcp_pkt_cnt, pDlg->udp_pkt_cnt, pDlg->arp_pkt_cnt, pDlg->icmp_pkt_cnt);[m
[32m  +	}[m
[32m  +[m
[32m  +[m
[32m  +	std::string result;[m
[32m  +[m
[32m  +	for (i = 1; (i < header->caplen + 1); i++) {[m
[32m  +		char* temp = NULL;[m
[32m  +[m
[32m  +		int temp2 = pkt_data[i - 1];[m
[32m  +		std::stringstream stream;[m
[32m  +		stream << std::setw(2) << std::setfill('0') << std::hex << temp2;[m
[32m  +[m
[32m  +		result += stream.str();[m
[32m  +	}[m
[32m  +[m
[32m  +[m
[32m  +	CString packet_dump_data(result.c_str());[m
[32m  +	int column_count = pDlg->m_ListCtrl.GetItemCount()-1;[m
[32m  +	pDlg->m_ListCtrl.SetItem(column_count, 7, LVIF_TEXT, packet_dump_data, NULL, NULL, NULL, NULL);[m
[32m  +[m
[32m  +[m
[32m  +}[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::OnBnClickedButton2()[m
[32m  +{[m
[32m  +	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.[m
[32m  +	if (m_pThread == NULL) {[m
[32m  +[m
[32m  +	}[m
[32m  +	else {[m
[32m  +		m_pThread->SuspendThread();[m
[32m  +[m
[32m  +		DWORD dwResult;[m
[32m  +		::GetExitCodeThread(m_pThread->m_hThread, &dwResult);[m
[32m  +[m
[32m  +		delete m_pThread;[m
[32m  +		m_pThread = NULL;[m
[32m  +[m
[32m  +		m_ThreadWorkType = STOP;[m
[32m  +[m
[32m  +		CButton* pButton = (CButton*)GetDlgItem(IDC_BUTTON1);[m
[32m  +		pButton->EnableWindow(TRUE);[m
[32m  +[m
[32m  +		CButton* pButton2 = (CButton*)GetDlgItem(IDC_BUTTON2);[m
[32m  +		pButton2->EnableWindow(FALSE);[m
[32m  +[m
[32m  +		CButton* pButton3 = (CButton*)GetDlgItem(IDC_BUTTON3);[m
[32m  +		pButton3->EnableWindow(FALSE);[m
[32m  +[m
[32m  +[m
[32m  +		ClearPacketCnt();[m
[32m  +		ChangeStaticText(packet_cnt, tcp_pkt_cnt, udp_pkt_cnt, arp_pkt_cnt, icmp_pkt_cnt);[m
[32m  +		m_ListCtrl.DeleteAllItems();[m
[32m  +		PacketDataCtrl.DeleteAllItems();[m
[32m  +		PacketDumpList.DeleteAllItems();[m
[32m  +	}[m
[32m  +}[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::	ChangeStaticText(int all_pkt_cnt, int tcp_pkt_cnt, int udp_pkt_cnt, int arp_pkt_cnt, int icmp_pkt_cnt){[m
[32m  +	SetDlgItemText(IDC_STATIC, [m
[32m  +		L"ALL : " + (CString)(std::to_string(all_pkt_cnt).c_str()) +[m
[32m  +		L" TCP : " + (CString)(std::to_string(tcp_pkt_cnt).c_str()) +[m
[32m  +		L" UDP : " + (CString)(std::to_string(udp_pkt_cnt).c_str()) +[m
[32m  +		L" ARP : " + (CString)(std::to_string(arp_pkt_cnt).c_str()) +[m
[32m  +		L" ICMP : " + (CString)(std::to_string(icmp_pkt_cnt).c_str())[m
[32m  +	);[m
[32m  +}[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::ClearPacketCnt() {[m
[32m  +	packet_cnt = 0;[m
[32m  +	tcp_pkt_cnt = 0;[m
[32m  +	udp_pkt_cnt = 0;[m
[32m  +	arp_pkt_cnt = 0;[m
[32m  +	icmp_pkt_cnt = 0;[m
[32m  +}[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::OnBnClickedButton3()[m
[32m  +{[m
[32m  +	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.[m
[32m  +	if (m_pThread == NULL) {[m
[32m  +	}[m
[32m  +	else {[m
[32m  +		if (m_ThreadWorkType == RUNNING) {[m
[32m  +			pause_button.SetWindowText(L"Resume");[m
[32m  +			m_pThread->SuspendThread();[m
[32m  +			m_ThreadWorkType = PAUSE;[m
[32m  +		}[m
[32m  +		else {[m
[32m  +			pause_button.SetWindowText(L"Pause");[m
[32m  +			m_pThread->ResumeThread();[m
[32m  +			m_ThreadWorkType = RUNNING;[m
[32m  +		}[m
[32m  +	}[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +std::string GetCurrentTimeStr(void) {[m
[32m  +	time_t     tm_time;[m
[32m  +	struct tm* st_time;[m
[32m  +	char       buff[1024];[m
[32m  +[m
[32m  +	time(&tm_time);[m
[32m  +	st_time = localtime(&tm_time);[m
[32m  +	strftime(buff, 1024, "%Y-%m-%d %p %H:%M:%S", st_time);[m
[32m  +[m
[32m  +	std::string temp_buf = buff;[m
[32m  +[m
[32m  +	return temp_buf;[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +CString CMFCApplication1Dlg::GetIPAddr(ip_address ip_addr) {[m
[32m  +	CString temp_ip_addr;[m
[32m  +	temp_ip_addr += CString(std::to_string(int(ip_addr.byte1)).c_str()) + L".";[m
[32m  +	temp_ip_addr += CString(std::to_string(int(ip_addr.byte2)).c_str()) + L".";[m
[32m  +	temp_ip_addr += CString(std::to_string(int(ip_addr.byte3)).c_str()) + L".";[m
[32m  +	temp_ip_addr += CString(std::to_string(int(ip_addr.byte4)).c_str());[m
[32m  +[m
[32m  +	return temp_ip_addr;[m
[32m  +}[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::OnCustomdrawList(NMHDR* pNMHDR, LRESULT* pResult) {[m
[32m  +[m
[32m  +	LPNMCUSTOMDRAW pNMCD = reinterpret_cast<LPNMCUSTOMDRAW>(pNMHDR);[m
[32m  +	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.[m
[32m  +	NMLVCUSTOMDRAW* pLVCD = (NMLVCUSTOMDRAW*)pNMHDR;[m
[32m  +[m
[32m  +	*pResult = 0;[m
[32m  +[m
[32m  +	if (CDDS_PREPAINT == pLVCD->nmcd.dwDrawStage) {[m
[32m  +		*pResult = CDRF_NOTIFYITEMDRAW;[m
[32m  +	}[m
[32m  +	else if (CDDS_ITEMPREPAINT == pLVCD->nmcd.dwDrawStage)[m
[32m  +	{[m
[32m  +		if (m_ListCtrl.GetItemText(pLVCD->nmcd.dwItemSpec, 4) == L"TCP") {[m
[31m-- 			//pLVCD->clrText = RGB(0, 0, 0, );  // 글자 색 변경 [m
[31m-- 			pLVCD->clrTextBk = RGB(218, 238, 255); // 배경 색 변경 [m
[32m+++			//pLVCD->clrText = RGB(0, 0, 0, );  // 글자 색 변경[m
[32m+++			pLVCD->clrTextBk = RGB(231, 230, 255); // 배경 색 변경 [m
[32m  +		}[m
[32m  +		else if (m_ListCtrl.GetItemText(pLVCD->nmcd.dwItemSpec, 4) == L"UDP") {[m
[31m-- 			pLVCD->clrTextBk = RGB(231, 230, 255);[m
[32m+++			pLVCD->clrTextBk = RGB(218, 238, 255);[m
[32m  +		}[m
[32m  +		else if (m_ListCtrl.GetItemText(pLVCD->nmcd.dwItemSpec, 4) == L"ICMP") {[m
[32m  +			pLVCD->clrTextBk = RGB(252, 224, 255);[m
[32m  +		}[m
[32m  +		else if (m_ListCtrl.GetItemText(pLVCD->nmcd.dwItemSpec, 4) == L"ARP") {[m
[32m  +			pLVCD->clrTextBk = RGB(250, 240, 215);[m
[32m  +		}[m
[32m  +[m
[32m  +		*pResult = CDRF_DODEFAULT;[m
[32m  +	}[m
[32m  +}[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::OnNMDblclkList2(NMHDR* pNMHDR, LRESULT* pResult)[m
[32m  +{[m
[32m  +	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);[m
[32m  +	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.[m
[32m  +	*pResult = 0;[m
[32m  +[m
[32m  +	pNMItemActivate->iItem;[m
[32m  +	if (pNMItemActivate->iItem != -1) {[m
[32m  +		CString FrameNumber = m_ListCtrl.GetItemText(pNMItemActivate->iItem, 0);[m
[32m  +		CString Time = m_ListCtrl.GetItemText(pNMItemActivate->iItem, 1);[m
[32m  +		CString Source = m_ListCtrl.GetItemText(pNMItemActivate->iItem, 2);[m
[32m  +		CString Destination = m_ListCtrl.GetItemText(pNMItemActivate->iItem, 3);[m
[32m  +		CString Protocol = m_ListCtrl.GetItemText(pNMItemActivate->iItem, 4);[m
[32m  +		CString Length = m_ListCtrl.GetItemText(pNMItemActivate->iItem, 5);[m
[32m  +		CString Info = m_ListCtrl.GetItemText(pNMItemActivate->iItem, 6);[m
[32m  +		CString Packet_Dump_Data = m_ListCtrl.GetItemText(pNMItemActivate->iItem, 7);[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +		PacketDataCtrl.DeleteAllItems();[m
[32m  +		PacketDataCtrl.Invalidate();[m
[32m  +[m
[32m+++		//===========================================================[m
[32m+++		CString PacketDataLine1;[m
[32m+++		CString PacketDataLine2;[m
[32m+++		CString PacketDataLine3;[m
[32m+++		CString PacketDataLine4;[m
[32m+++[m
[32m+++		PacketDataLine1 = L"Frame " + FrameNumber + L": "[m
[32m+++			+ Length + L"bytes on wire (" + CString(std::to_string(_ttoi(Length) * 8).c_str()) + L" bits), "[m
[32m+++			+ Length + L"bytes captured (" + CString(std::to_string(_ttoi(Length) * 8).c_str()) + L" bits) on interface 0";[m
[32m+++[m
[32m+++		CString PakcetDataLine1by1 = L"Interface id: 0 (" + netInterfaceDlg.InterfaceName + L")";[m
[32m+++		CString PakcetDataLine1by1by1 = L"Interface name: " + netInterfaceDlg.InterfaceName;[m
[32m+++		CString PakcetDataLine1by1by2 = L"Interface desciption: " + netInterfaceDlg.InterfaceDescription;[m
[32m+++[m
[32m+++		CString PakcetDataLine1by2 = L"Encapsulation type: Ethernet (1)";[m
[32m+++		CString PakcetDataLine1by3 = L"Arrival Time: " + Time;[m
[32m+++		CString PakcetDataLine1by4 = L"Frame Number: " + FrameNumber;[m
[32m+++		CString PakcetDataLine1by5 = L"Frame Length: " + Length + L" bytes (" + CString(std::to_string(_ttoi(Length) * 8).c_str()) + L" bits)";[m
[32m+++		CString PakcetDataLine1by6 = L"Capture Length: " + Length + L" bytes (" + CString(std::to_string(_ttoi(Length) * 8).c_str()) + L" bits)";[m
[32m+++[m
[32m+++[m
[32m+++		CString Destination_addr = Packet_Dump_Data.Mid(0, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(2, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(4, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(6, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(8, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(10, 2);[m
[32m+++[m
[32m+++		CString Source_addr = Packet_Dump_Data.Mid(12, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(14, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(16, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(18, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(20, 2) + L":"[m
[32m+++			+ Packet_Dump_Data.Mid(22, 2);[m
[32m+++[m
[32m+++		PacketDataLine2 = L"Ethernet ⅠⅠ, Src: " + Source_addr + L", Dst: " + Destination_addr;[m
[32m+++		CString PakcetDataLine2by1 = L"Destination: " + Destination_addr;[m
[32m+++		CString PakcetDataLine2by2 = L"Source: " + Source_addr;[m
[32m+++[m
[32m+++		// IPv6 일때 작동하도록 수정[m
[32m+++		CString PakcetDataLine2by3 = L"Type: IPv4 (0x" + Packet_Dump_Data.Mid(24, 2) + L")";[m
[32m+++		CString PakcetDataLine2by4 = L"Padding: " + Packet_Dump_Data.Mid(108, 12);[m
[32m+++[m
[32m+++		CString ipVersion = Packet_Dump_Data.Mid(28, 1);[m
[32m+++		CString headerLength = Packet_Dump_Data.Mid(29, 1);[m
[32m+++[m
[32m+++[m
[32m+++		CString totalLength = CString(std::to_string([m
[32m+++			(_ttoi(HexToDec(Packet_Dump_Data.Mid(32, 1))) * 4096 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(33, 1))) * 256 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(34, 1))) * 16 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(35, 1))) * 1[m
[32m+++				)).c_str());[m
[32m+++[m
[32m+++		CString identification = CString(std::to_string([m
[32m+++			(_ttoi(HexToDec(Packet_Dump_Data.Mid(36, 1))) * 4096 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(37, 1))) * 256 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(38, 1))) * 16 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(39, 1))) * 1[m
[32m+++				)).c_str());[m
[32m+++[m
[32m+++		CString timeToLive = CString(std::to_string([m
[32m+++			(_ttoi(HexToDec(Packet_Dump_Data.Mid(44, 1))) * 16 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(45, 1))) * 1[m
[32m+++				)).c_str());[m
[32m+++[m
[32m+++		CString ptotocol = CString(std::to_string([m
[32m+++			(_ttoi(HexToDec(Packet_Dump_Data.Mid(46, 1))) * 16 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(47, 1))) * 1[m
[32m+++				)).c_str());[m
[32m+++[m
[32m+++		PacketDataLine3 = L"Internet Protocol Version " + ipVersion + L", Src: " + Source + L", Dst: " + Destination;[m
[32m+++[m
[32m+++		CString ipVersionBinary = HexToBinary(HexToDec(ipVersion));[m
[32m+++		CString headerLengthBinary = HexToBinary(HexToDec(headerLength));[m
[32m+++[m
[32m+++		CString PacketDataLine3by1 = ipVersionBinary + L"  . . . . = Version: " + ipVersion;[m
[32m+++		CString PacketDataLine3by2 = L". . . .  " + headerLengthBinary + " = Header Length: " + CString(std::to_string((_ttoi(headerLength) * 4)).c_str()) + L" bytes (" + headerLength + L")";[m
[32m+++[m
[32m+++[m
[32m+++		CString PacketDataLine3by3 = L"Differentinated Services Field: 0x" + Packet_Dump_Data.Mid(30, 2);[m
[32m+++		CString PacketDataLine3by4 = L"Total Length: " + totalLength;[m
[32m+++		CString PacketDataLine3by5 = L"Identification: 0x" + Packet_Dump_Data.Mid(36, 4) + L" (" + identification + L")";[m
[32m+++		CString PacketDataLine3by6 = L"Flags: 0x" + Packet_Dump_Data.Mid(40, 4);[m
[32m+++		CString PacketDataLine3by7 = L"Time to live: " + timeToLive;[m
[32m+++		CString PacketDataLine3by8 = L"Protocol: " + Protocol + L"(" + ptotocol + L")";[m
[32m+++		CString PacketDataLine3by9 = L"Header checksum: " + Packet_Dump_Data.Mid(48, 4); +L")";[m
[32m+++		CString PacketDataLine3by10 = L"Source: " + Source;[m
[32m+++		CString PacketDataLine3by11 = L"Destination: " + Destination;[m
[32m+++[m
[32m+++		CString Line4SourcePort = CString(std::to_string([m
[32m+++			(_ttoi(HexToDec(Packet_Dump_Data.Mid(68, 1))) * 4096 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(69, 1))) * 256 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(70, 1))) * 16 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(71, 1))) * 1[m
[32m+++				)).c_str());[m
[32m+++[m
[32m+++		CString Line4DestinationPort = CString(std::to_string([m
[32m+++			(_ttoi(HexToDec(Packet_Dump_Data.Mid(72, 1))) * 4096 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(73, 1))) * 256 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(74, 1))) * 16 +[m
[32m+++				_ttoi(HexToDec(Packet_Dump_Data.Mid(75, 1))) * 1[m
[32m+++				)).c_str());[m
[32m+++[m
[32m+++		// Line 1[m
[32m+++		HTREEITEM  PacketDataRoot1 = PacketDataCtrl.InsertItem(PacketDataLine1);[m
[32m+++		HTREEITEM  PacketDataRoot1Child1 = PacketDataCtrl.InsertItem(PakcetDataLine1by1, PacketDataRoot1);[m
[32m+++		HTREEITEM  PacketDataRoot1Child1Child1 = PacketDataCtrl.InsertItem(PakcetDataLine1by1by1, PacketDataRoot1Child1);[m
[32m+++		HTREEITEM  PacketDataRoot1Child1Child2 = PacketDataCtrl.InsertItem(PakcetDataLine1by1by2, PacketDataRoot1Child1);[m
[32m+++[m
[32m+++		HTREEITEM  PacketDataRoot1Child2 = PacketDataCtrl.InsertItem(PakcetDataLine1by2, PacketDataRoot1);[m
[32m+++		HTREEITEM  PacketDataRoot1Child3 = PacketDataCtrl.InsertItem(PakcetDataLine1by3, PacketDataRoot1);[m
[32m+++		HTREEITEM  PacketDataRoot1Child4 = PacketDataCtrl.InsertItem(PakcetDataLine1by4, PacketDataRoot1);[m
[32m+++		HTREEITEM  PacketDataRoot1Child5 = PacketDataCtrl.InsertItem(PakcetDataLine1by5, PacketDataRoot1);[m
[32m+++		HTREEITEM  PacketDataRoot1Child6 = PacketDataCtrl.InsertItem(PakcetDataLine1by6, PacketDataRoot1);[m
[32m+++[m
[32m+++[m
[32m+++		// Line 2[m
[32m+++		HTREEITEM  PacketDataRoot2 = PacketDataCtrl.InsertItem(PacketDataLine2);[m
[32m+++		HTREEITEM  PacketDataRoot2Child1 = PacketDataCtrl.InsertItem(PakcetDataLine2by1, PacketDataRoot2);[m
[32m+++		HTREEITEM  PacketDataRoot2Child2 = PacketDataCtrl.InsertItem(PakcetDataLine2by2, PacketDataRoot2);[m
[32m+++		HTREEITEM  PacketDataRoot2Child3 = PacketDataCtrl.InsertItem(PakcetDataLine2by3, PacketDataRoot2);[m
[32m+++		if (Length == L"60") {[m
[32m+++			HTREEITEM  PacketDataRoot2Child4 = PacketDataCtrl.InsertItem(PakcetDataLine2by4, PacketDataRoot2);[m
[32m+++		}[m
[32m+++[m
[32m+++[m
[32m+++		// Line 3[m
[32m+++		HTREEITEM  PacketDataRoot3 = PacketDataCtrl.InsertItem(PacketDataLine3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child1 = PacketDataCtrl.InsertItem(PacketDataLine3by1, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child2 = PacketDataCtrl.InsertItem(PacketDataLine3by2, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child3 = PacketDataCtrl.InsertItem(PacketDataLine3by3, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child4 = PacketDataCtrl.InsertItem(PacketDataLine3by4, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child5 = PacketDataCtrl.InsertItem(PacketDataLine3by5, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child6 = PacketDataCtrl.InsertItem(PacketDataLine3by6, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child7 = PacketDataCtrl.InsertItem(PacketDataLine3by7, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child8 = PacketDataCtrl.InsertItem(PacketDataLine3by8, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child9 = PacketDataCtrl.InsertItem(PacketDataLine3by9, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child10 = PacketDataCtrl.InsertItem(PacketDataLine3by10, PacketDataRoot3);[m
[32m+++		HTREEITEM  PacketDataRoot3Child11 = PacketDataCtrl.InsertItem(PacketDataLine3by11, PacketDataRoot3);[m
[32m+++[m
[32m+++[m
[32m+++		//=======================================[m
[32m  +		if (Protocol == L"TCP") {[m
[32m  +			/*[m
[32m  +			Frame 123: 60 bytes on wire (480bits), 60 bytes captured (480 bits) on interface 0[m
[32m  +			Ethernet II, Src: FF:FF:FF:FF:FF:FF, Dst: 00:00:00:00:00:00[m
[32m  +			Internet Protocol Version 4, Src: 192.168.0.1, Dst: 127.0.0.1[m
[32m  +			Transmission Control Protocol, Src Port: 9999, Dst Port: 666, Seq: 64, Ack: 1, Len: 0[m
[32m  +			*/[m
[31m-- 			CString PacketDataLine1;[m
[31m-- 			CString PacketDataLine2;[m
[31m-- 			CString PacketDataLine3;[m
[31m-- 			CString PacketDataLine4;[m
[31m-- [m
[31m-- 			PacketDataLine1 = L"Frame " + FrameNumber + L": "[m
[31m-- 				+ Length + L"bytes on wire (" + CString(std::to_string(_ttoi(Length)*8).c_str()) + L" bits), "[m
[31m-- 				+ Length + L"bytes captured (" + CString(std::to_string(_ttoi(Length) * 8).c_str()) + L" bits) on interface 0";[m
[31m-- [m
[31m-- 			CString PakcetDataLine1by1 = L"Interface id: 0 (" + netInterfaceDlg.InterfaceName + L")";[m
[31m-- 			CString PakcetDataLine1by1by1 = L"Interface name: " + netInterfaceDlg.InterfaceName;[m
[31m-- 			CString PakcetDataLine1by1by2 = L"Interface desciption: " + netInterfaceDlg.InterfaceDescription;[m
[31m-- [m
[31m-- 			CString PakcetDataLine1by2 = L"Encapsulation type: Ethernet (1)";[m
[31m-- 			CString PakcetDataLine1by3 = L"Arrival Time: " + Time;[m
[31m-- 			CString PakcetDataLine1by4 = L"Frame Number: " + FrameNumber;[m
[31m-- 			CString PakcetDataLine1by5 = L"Frame Length: " + Length + L" bytes ("+ CString(std::to_string(_ttoi(Length) * 8).c_str()) + L" bits)";[m
[31m-- 			CString PakcetDataLine1by6 = L"Capture Length: " + Length + L" bytes (" + CString(std::to_string(_ttoi(Length) * 8).c_str()) + L" bits)";[m
[31m-- [m
[31m-- [m
[31m-- 			CString Destination_addr = Packet_Dump_Data.Mid(0, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(2, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(4, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(6, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(8, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(10, 2);[m
[31m-- [m
[31m-- 			CString Source_addr = Packet_Dump_Data.Mid(12, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(14, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(16, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(18, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(20, 2) + L":"[m
[31m-- 				+ Packet_Dump_Data.Mid(22, 2);[m
[31m-- [m
[31m-- 			PacketDataLine2 = L"Ethernet ⅠⅠ, Src: " + Source_addr + L", Dst: " + Destination_addr;[m
[31m-- 			CString PakcetDataLine2by1 = L"Destination: " + Destination_addr;[m
[31m-- 			CString PakcetDataLine2by2 = L"Source: " + Source_addr;[m
[31m-- 			CString PakcetDataLine2by3 = L"Type: IPv4 (0x" + Packet_Dump_Data.Mid(24, 2) + L")";[m
[31m-- 			CString PakcetDataLine2by4 = L"Padding: " + Packet_Dump_Data.Mid(108, 12);[m
[31m-- [m
[31m-- 			CString ipVersion = Packet_Dump_Data.Mid(28, 1);[m
[31m-- 			CString headerLength = Packet_Dump_Data.Mid(29, 1);[m
[31m-- 			PacketDataLine3 = L"Internet Protocol Version "+ ipVersion +L", Src: " + Source + L", Dst: " + Destination;[m
[31m-- 			CString PacketDataLine3by1 = L".... .... = Version: " + ipVersion;[m
[31m-- [m
[31m-- 			// 이부분 빅 엔디안에서 리틀 엔디안 으로 변경해야함[m
[31m-- 			CString PacketDataLine3by2 = L".... .... = Header Length: " + CString(std::to_string(ntohs(_ttoi(headerLength))).c_str()) + L" bytes " + headerLength;[m
[31m-- [m
[31m-- 			PacketDataLine4;[m
[31m-- [m
[31m-- [m
[31m-- 			// Line 1[m
[31m-- 			HTREEITEM  PacketDataRoot1 = PacketDataCtrl.InsertItem(PacketDataLine1);[m
[31m-- 			HTREEITEM  PacketDataRoot1Child1 = PacketDataCtrl.InsertItem(PakcetDataLine1by1, PacketDataRoot1);[m
[31m-- 			HTREEITEM  PacketDataRoot1Child1Child1 = PacketDataCtrl.InsertItem(PakcetDataLine1by1by1, PacketDataRoot1Child1);[m
[31m-- 			HTREEITEM  PacketDataRoot1Child1Child2 = PacketDataCtrl.InsertItem(PakcetDataLine1by1by2, PacketDataRoot1Child1);[m
[31m-- [m
[31m-- 			HTREEITEM  PacketDataRoot1Child2 = PacketDataCtrl.InsertItem(PakcetDataLine1by2, PacketDataRoot1);[m
[31m-- 			HTREEITEM  PacketDataRoot1Child3 = PacketDataCtrl.InsertItem(PakcetDataLine1by3, PacketDataRoot1);[m
[31m-- 			HTREEITEM  PacketDataRoot1Child4 = PacketDataCtrl.InsertItem(PakcetDataLine1by4, PacketDataRoot1);[m
[31m-- 			HTREEITEM  PacketDataRoot1Child5 = PacketDataCtrl.InsertItem(PakcetDataLine1by5, PacketDataRoot1);[m
[31m-- 			HTREEITEM  PacketDataRoot1Child6 = PacketDataCtrl.InsertItem(PakcetDataLine1by6, PacketDataRoot1);[m
[31m-- [m
[31m-- [m
[31m-- 			// Line 2[m
[31m-- 			HTREEITEM  PacketDataRoot2 = PacketDataCtrl.InsertItem(PacketDataLine2);[m
[31m-- 			HTREEITEM  PacketDataRoot2Child1 = PacketDataCtrl.InsertItem(PakcetDataLine2by1, PacketDataRoot2);[m
[31m-- 			HTREEITEM  PacketDataRoot2Child2 = PacketDataCtrl.InsertItem(PakcetDataLine2by2, PacketDataRoot2);[m
[31m-- 			HTREEITEM  PacketDataRoot2Child3 = PacketDataCtrl.InsertItem(PakcetDataLine2by3, PacketDataRoot2);[m
[31m-- 			if (Length == L"60") {[m
[31m-- 				HTREEITEM  PacketDataRoot2Child4 = PacketDataCtrl.InsertItem(PakcetDataLine2by4, PacketDataRoot2);[m
[32m+++			[m
[32m+++[m
[32m+++[m
[32m+++			PacketDataLine4 = L"Transmission Control Protocol, Src Port: " + Line4SourcePort + L", Dst Port: " + Line4DestinationPort;[m
[32m+++			CString PacketDataLine4by1 = L"Source Port: " + Line4SourcePort;[m
[32m+++			CString PacketDataLine4by2 = L"Destination Port: " + Line4DestinationPort;[m
[32m+++			CString PacketDataLine4by3 = L"Sequence number: " + Packet_Dump_Data.Mid(76, 8);[m
[32m+++			CString PacketDataLine4by4 = L"Acknowledge number: " + Packet_Dump_Data.Mid(84, 8);[m
[32m+++			CString PacketDataLine4by5 = HexToBinary(HexToDec(Packet_Dump_Data.Mid(92,1))) + L" . . . . = Header Length: " [m
[32m+++				+ CString(std::to_string(_ttoi(Packet_Dump_Data.Mid(92, 1))*4).c_str()) + " bytes ("[m
[32m+++				+ CString(std::to_string(_ttoi(Packet_Dump_Data.Mid(92, 1))).c_str())+")";[m
[32m+++			[m
[32m+++[m
[32m+++			// Reserver+Flag;[m
[32m+++			// 6bits -> Reserved[m
[32m+++			CString BinaryTCPFlag = GetTCPFlagToBin(Packet_Dump_Data.Mid(93, 3));[m
[32m+++[m
[32m+++			CString Reserved = BinaryTCPFlag.Mid(0, 3);[m
[32m+++			CString Nonce = BinaryTCPFlag.Mid(3, 1);[m
[32m+++			CString CongestionWindowReduced = BinaryTCPFlag.Mid(4, 1);[m
[32m+++			CString ECN_Echo = BinaryTCPFlag.Mid(5, 1);[m
[32m+++[m
[32m+++			// Flag[m
[32m+++			// 6bits -> Flags[m
[32m+++			CString Urgent = BinaryTCPFlag.Mid(6, 1);[m
[32m+++			CString Acknowledgment = BinaryTCPFlag.Mid(7, 1);[m
[32m+++			CString Push = BinaryTCPFlag.Mid(8, 1);[m
[32m+++			CString Reset = BinaryTCPFlag.Mid(9, 1);[m
[32m+++			CString Syn = BinaryTCPFlag.Mid(10, 1);[m
[32m+++			CString Fin = BinaryTCPFlag.Mid(11, 1);[m
[32m+++[m
[32m+++			// Only Binary Flag;[m
[32m+++			CString TCPFlagBinaryOnly;[m
[32m+++[m
[32m+++			for (int i = 6; i < 12; i++) {[m
[32m+++				TCPFlagBinaryOnly.Append(BinaryTCPFlag.Mid(i, 1));[m
[32m  +			}[m
[32m  +[m
[32m  +[m
[32m+++			// TCP Flags:  . . . . . . .A . . .F 의 형식[m
[32m+++			CString TCPFlagLongStr = GetTCPFlagToLongStr(BinaryTCPFlag);[m
[32m  +[m
[31m-- 			// Line 3[m
[31m-- 			HTREEITEM  PacketDataRoot3 = PacketDataCtrl.InsertItem(PacketDataLine3);[m
[31m-- 			HTREEITEM  PacketDataRoot3Child1 = PacketDataCtrl.InsertItem(PacketDataLine3by1, PacketDataRoot3);[m
[31m-- 			HTREEITEM  PacketDataRoot3Child2 = PacketDataCtrl.InsertItem(PacketDataLine3by2, PacketDataRoot3);[m
[32m+++			CString PacketDataLine4by6 = L"Flags: 0x" + Packet_Dump_Data.Mid(93, 3) + L"(" + GetTCPFlagToStr(TCPFlagBinaryOnly) + L")";[m
[32m  +[m
[31m-- 			HTREEITEM  PacketDataRoot4 = PacketDataCtrl.InsertItem(PacketDataLine4);[m
[31m-- 			HTREEITEM  PacketDataRoot4Child1 = PacketDataCtrl.InsertItem(PacketDataLine4, PacketDataRoot4);[m
[32m+++			CString PacketDataLine4by6by1 = Reserved;[m
[32m+++			CString PacketDataLine4by6by2 = Nonce;[m
[32m+++			CString PacketDataLine4by6by3 = CongestionWindowReduced;[m
[32m+++			CString PacketDataLine4by6by4 = ECN_Echo;[m
[32m+++			CString PacketDataLine4by6by5 = Urgent;[m
[32m+++			CString PacketDataLine4by6by6 = Acknowledgment;[m
[32m+++			CString PacketDataLine4by6by7 = Push;[m
[32m+++			CString PacketDataLine4by6by8 = Reset;[m
[32m+++			CString PacketDataLine4by6by9 = Syn;[m
[32m+++			CString PacketDataLine4by6by10 = Fin;[m
[32m+++			CString PacketDataLine4by6by11 = L"[TCP Flags: " + TCPFlagLongStr+"]";[m
[32m  +[m
[32m  +[m
[32m+++			// Reserved[m
[32m+++			if (PacketDataLine4by6by1 != L"000") {[m
[32m+++				PacketDataLine4by6by1 = Reserved + L".  . . . .  . . . . = Reserved: Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by1 = Reserved + L".  . . . .  . . . . = Reserved: Not set";[m
[32m+++			}[m
[32m  +[m
[31m-- 			PacketDataCtrl.Expand(PacketDataRoot1, TVE_EXPAND);[m
[31m-- 			PacketDataCtrl.Expand(PacketDataRoot2, TVE_EXPAND);[m
[31m-- 			PacketDataCtrl.Expand(PacketDataRoot3, TVE_EXPAND);[m
[31m-- 			PacketDataCtrl.Expand(PacketDataRoot4, TVE_EXPAND);[m
[32m+++			// Nonce[m
[32m+++			if (PacketDataLine4by6by2 != L"0") {[m
[32m+++				PacketDataLine4by6by2 = L". . ." + Nonce + L"  . . . .  . . . . = Nonce: Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by2 = L". . ." + Nonce + L"  . . . .  . . . . = Nonce: Noe set";[m
[32m+++			}[m
[32m+++[m
[32m+++			// CongestionWindowReduced[m
[32m+++			if (PacketDataLine4by6by3 != L"0") {[m
[32m+++				PacketDataLine4by6by3 = L". . . .  " + CongestionWindowReduced + L". . .  . . . . = CongestionWindowReduced (CWR) : Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by3 = L". . . .  " + CongestionWindowReduced + L". . .  . . . . = CongestionWindowReduced (CWR) : Not set";[m
[32m+++			}[m
[32m+++[m
[32m+++			// ECN_Echo[m
[32m+++			if (PacketDataLine4by6by4 != L"0") {[m
[32m+++				PacketDataLine4by6by4 = L". . . .  . " + ECN_Echo + L". .  . . . . = ECN-Echo : Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by4 = L". . . .  . " + ECN_Echo + L". .  . . . . = ECN-Echo : Not set";[m
[32m+++			}[m
[32m+++[m
[32m+++			// Urgent[m
[32m+++			if (PacketDataLine4by6by5 != L"0") {[m
[32m+++				PacketDataLine4by6by5 = L". . . .  . . " + Urgent + L".  . . . . = Urgent : Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by5 = L". . . .  . . " + Urgent + L".  . . . . = Urgent : Not set";[m
[32m+++			}[m
[32m+++[m
[32m+++			// Acknowledgment[m
[32m+++			if (PacketDataLine4by6by6 != L"0") {[m
[32m+++				PacketDataLine4by6by6 = L". . . .  . . ." + Acknowledgment + L"  . . . . = Acknowledgment : Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by6 = L". . . .  . . ." + Acknowledgment + L"  . . . . = Acknowledgment : Not set";[m
[32m+++			}[m
[32m  +[m
[32m+++			// Push[m
[32m+++			if (PacketDataLine4by6by7 != L"0") {[m
[32m+++				PacketDataLine4by6by7 = L". . . .  . . . .  " + Push + L". . . = Push : Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by7 = L". . . .  . . . .  " + Push + L". . . = Push : Not set";[m
[32m+++			}[m
[32m+++[m
[32m+++			// Reset[m
[32m+++			if (PacketDataLine4by6by8 != L"0") {[m
[32m+++				PacketDataLine4by6by8 = L". . . .  . . . .  . " + Reset + L". . = Reset : Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by8 = L". . . .  . . . .  . " + Reset + L". . = Reset : Not set";[m
[32m+++			}[m
[32m+++[m
[32m+++			// Syn[m
[32m+++			if (PacketDataLine4by6by9 != L"0") {[m
[32m+++				PacketDataLine4by6by9 = L". . . .  . . . .  . . " + Syn + L". = Syn : Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by9 = L". . . .  . . . .  . . " + Syn + L". = Syn : Not set";[m
[32m+++			}[m
[32m+++[m
[32m+++			// Fin[m
[32m+++			if (PacketDataLine4by6by10 != L"0") {[m
[32m+++				PacketDataLine4by6by10 = L". . . .  . . . .  . . . " + Fin + L" = Fin : Set";[m
[32m+++			}[m
[32m+++			else {[m
[32m+++				PacketDataLine4by6by10 = L". . . .  . . . .  . . ." + Fin + L" = Fin : Not set";[m
[32m+++			}[m
[32m+++[m
[32m+++			CString windowSize = CString(std::to_string([m
[32m+++				(_ttoi(HexToDec(Packet_Dump_Data.Mid(96, 1))) * 4096 +[m
[32m+++					_ttoi(HexToDec(Packet_Dump_Data.Mid(97, 1))) * 256 +[m
[32m+++					_ttoi(HexToDec(Packet_Dump_Data.Mid(98, 1))) * 16 +[m
[32m+++					_ttoi(HexToDec(Packet_Dump_Data.Mid(99, 1))) * 1[m
[32m+++					)).c_str());[m
[32m+++[m
[32m+++			CString PacketDataLine4by7 = L"Window size value: " + windowSize;[m
[32m+++			CString PacketDataLine4by8 = L"[Calculated window size: " + windowSize + L"]";[m
[32m+++			CString PacketDataLine4by9 = L"Checksum: 0x"+ Packet_Dump_Data.Mid(100, 4);[m
[32m+++[m
[32m+++			CString urgentPointer = CString(std::to_string([m
[32m+++				(_ttoi(HexToDec(Packet_Dump_Data.Mid(104, 1))) * 4096 +[m
[32m+++					_ttoi(HexToDec(Packet_Dump_Data.Mid(105, 1))) * 256 +[m
[32m+++					_ttoi(HexToDec(Packet_Dump_Data.Mid(106, 1))) * 16 +[m
[32m+++					_ttoi(HexToDec(Packet_Dump_Data.Mid(107, 1))) * 1[m
[32m+++					)).c_str());[m
[32m+++[m
[32m+++			CString PacketDataLine4by10 = L"Urgent pointer: " + urgentPointer;[m
[32m+++[m
[32m+++[m
[32m+++[m
[32m+++[m
[32m+++			[m
[32m+++[m
[32m+++			// Line 4[m
[32m+++			HTREEITEM  PacketDataRoot4 = PacketDataCtrl.InsertItem(PacketDataLine4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child1 = PacketDataCtrl.InsertItem(PacketDataLine4by1, PacketDataRoot4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child2 = PacketDataCtrl.InsertItem(PacketDataLine4by2, PacketDataRoot4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child3 = PacketDataCtrl.InsertItem(PacketDataLine4by3, PacketDataRoot4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child4 = PacketDataCtrl.InsertItem(PacketDataLine4by4, PacketDataRoot4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child5 = PacketDataCtrl.InsertItem(PacketDataLine4by5, PacketDataRoot4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6 = PacketDataCtrl.InsertItem(PacketDataLine4by6, PacketDataRoot4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child1 = PacketDataCtrl.InsertItem(PacketDataLine4by6by1, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child2 = PacketDataCtrl.InsertItem(PacketDataLine4by6by2, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child3 = PacketDataCtrl.InsertItem(PacketDataLine4by6by3, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child4 = PacketDataCtrl.InsertItem(PacketDataLine4by6by4, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child5 = PacketDataCtrl.InsertItem(PacketDataLine4by6by5, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child6 = PacketDataCtrl.InsertItem(PacketDataLine4by6by6, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child7 = PacketDataCtrl.InsertItem(PacketDataLine4by6by7, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child8 = PacketDataCtrl.InsertItem(PacketDataLine4by6by8, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child9 = PacketDataCtrl.InsertItem(PacketDataLine4by6by9, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child10 = PacketDataCtrl.InsertItem(PacketDataLine4by6by10, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child6Child11 = PacketDataCtrl.InsertItem(PacketDataLine4by6by11, PacketDataRoot4Child6);[m
[32m+++			HTREEITEM  PacketDataRoot4Child7 = PacketDataCtrl.InsertItem(PacketDataLine4by7, PacketDataRoot4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child8 = PacketDataCtrl.InsertItem(PacketDataLine4by8, PacketDataRoot4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child9 = PacketDataCtrl.InsertItem(PacketDataLine4by9, PacketDataRoot4);[m
[32m+++			HTREEITEM  PacketDataRoot4Child10 = PacketDataCtrl.InsertItem(PacketDataLine4by10, PacketDataRoot4);[m
[32m+++[m
[32m+++			PacketDataCtrl.Expand(PacketDataRoot4, TVE_EXPAND);[m
[32m  +		}else if (Protocol == L"UDP") {[m
[32m  +[m
[32m  +		}[m
[32m  +		else if (Protocol == L"ARP") {[m
[32m+++			//Frame, Ethernet 으로 되어있음[m
[32m  +[m
[32m  +		}[m
[32m  +		else if (Protocol == L"ICMP") {[m
[32m  +[m
[32m  +		}[m
[32m  +[m
[32m  +[m
[32m+++		PacketDataCtrl.Expand(PacketDataRoot1, TVE_EXPAND);[m
[32m+++		PacketDataCtrl.Expand(PacketDataRoot2, TVE_EXPAND);[m
[32m+++		PacketDataCtrl.Expand(PacketDataRoot3, TVE_EXPAND);[m
[32m+++[m
[32m  +[m
[32m  +		PacketDataCtrl.Invalidate();[m
[32m  +		PacketDataCtrl.UpdateWindow();[m
[32m  +	}[m
[32m  +[m
[32m  +[m
[32m  +	PacketDumpList.DeleteAllItems();[m
[32m  +	CString Packet_dump_data = m_ListCtrl.GetItemText(pNMItemActivate->iItem, 7);[m
[32m  +[m
[32m  +	if (Packet_dump_data != L"") {[m
[32m  +		for (int i = 0; i < Packet_dump_data.GetLength() + 1; i += 32) {[m
[32m  +			int column_count = PacketDumpList.GetItemCount();[m
[32m  +			CString column_count_str;[m
[32m  +			column_count_str.Format(_T("%d"), column_count + 1);[m
[32m  +[m
[32m  +			std::stringstream stream;[m
[32m  +			stream << std::setw(6) << std::setfill('0') << std::hex << (i / 2);[m
[32m  +[m
[32m  +			std::string seq_number_str = stream.str();[m
[32m  +			LPCSTR lpcstrSeqNum = (LPCSTR)seq_number_str.c_str();[m
[32m  +			USES_CONVERSION;[m
[32m  +			CString CstrSeqNum = A2CT(lpcstrSeqNum);[m
[32m  +			CstrSeqNum.MakeUpper();[m
[32m  +			PacketDumpList.InsertItem(column_count, CstrSeqNum);[m
[32m  +[m
[32m  +			CString allHex = Packet_dump_data.Mid(i, 32);[m
[32m  +			CString AsciiAllHex = allHex;[m
[32m  +			allHex = allHex.MakeUpper();[m
[32m  +[m
[32m  +			CString hex1, hex2;[m
[32m  +[m
[32m  +			for (int i = 0; i < 16; i += 2) {[m
[32m  +				hex1 += allHex.Mid(i, 2) + L"  ";[m
[32m  +			}[m
[32m  +[m
[32m  +			for (int i = 16; i < 32; i += 2) {[m
[32m  +				hex2 += allHex.Mid(i, 2) + L"  ";[m
[32m  +			}[m
[32m  +[m
[32m  +			PacketDumpList.SetItem(column_count, 1, LVIF_TEXT, hex1, NULL, NULL, NULL, NULL);[m
[32m  +			PacketDumpList.SetItem(column_count, 2, LVIF_TEXT, hex2, NULL, NULL, NULL, NULL);[m
[32m  +[m
[32m  +			CString convAscii;[m
[32m  +			CString PacketAscii1;[m
[32m  +			CString PacketAscii2;[m
[32m  +[m
[32m  +			for (int i = 0; i < AsciiAllHex.GetLength(); i += 2) {[m
[32m  +				PacketAscii1 = AsciiAllHex.Mid(i, 1);[m
[32m  +				PacketAscii2 = AsciiAllHex.Mid(i + 1, 1);[m
[32m  +[m
[32m  +				if (PacketAscii1 == L"a") {[m
[32m  +					PacketAscii1 = L"10";[m
[32m  +				}[m
[32m  +				if (PacketAscii1 == L"b") {[m
[32m  +					PacketAscii1 = L"11";[m
[32m  +				}[m
[32m  +				if (PacketAscii1 == L"c") {[m
[32m  +					PacketAscii1 = L"12";[m
[32m  +				}[m
[32m  +				if (PacketAscii1 == L"d") {[m
[32m  +					PacketAscii1 = L"13";[m
[32m  +				}[m
[32m  +				if (PacketAscii1 == L"e") {[m
[32m  +					PacketAscii1 = L"14";[m
[32m  +				}[m
[32m  +				if (PacketAscii1 == L"f") {[m
[32m  +					PacketAscii1 = L"15";[m
[32m  +				}[m
[32m  +[m
[32m  +				if (PacketAscii2 == L"a") {[m
[32m  +					PacketAscii2 = L"10";[m
[32m  +				}[m
[32m  +				if (PacketAscii2 == L"b") {[m
[32m  +					PacketAscii2 = L"11";[m
[32m  +				}[m
[32m  +				if (PacketAscii2 == L"c") {[m
[32m  +					PacketAscii2 = L"12";[m
[32m  +				}[m
[32m  +				if (PacketAscii2 == L"d") {[m
[32m  +					PacketAscii2 = L"13";[m
[32m  +				}[m
[32m  +				if (PacketAscii2 == L"e") {[m
[32m  +					PacketAscii2 = L"14";[m
[32m  +				}[m
[32m  +				if (PacketAscii2 == L"f") {[m
[32m  +					PacketAscii2 = L"15";[m
[32m  +				}[m
[32m  +[m
[32m  +				int ten = _ttoi(PacketAscii1) * 16;[m
[32m  +				int one = _ttoi(PacketAscii2);[m
[32m  +[m
[32m  +				int sum = ten + one;[m
[32m  +				ten = 0;[m
[32m  +				one = 0;[m
[32m  +[m
[32m  +				if (sum < 32 || sum>126) {[m
[32m  +					sum = 46;[m
[32m  +				}[m
[32m  +[m
[32m  +				char ascii[4];[m
[32m  +				ascii[0] = (char)sum;[m
[32m  +				if (sum == 46) {[m
[32m  +					sprintf(ascii, "%2c", ascii[0]);[m
[32m  +				}[m
[32m  +				else {[m
[32m  +					sprintf(ascii, "%c", ascii[0]);[m
[32m  +				}[m
[32m  +				convAscii += ascii;[m
[32m  +			}[m
[32m  +[m
[32m  +			PacketDumpList.SetItem(column_count, 3, LVIF_TEXT, convAscii, NULL, NULL, NULL, NULL);[m
[32m  +		}[m
[32m  +	}[m
[32m  +}[m
[32m  +[m
[32m  +void CMFCApplication1Dlg::OnHdnItemclick(NMHDR* pNMHDR, LRESULT* pResult)[m
[32m  +{[m
[32m  +	LPNMHEADER pNMLV = reinterpret_cast<LPNMHEADER>(pNMHDR);[m
[32m  +[m
[32m  +	int nColumn = pNMLV->iItem;[m
[32m  +	// 선택된 헤더 숫자로 정렬해야되는 값은 0번 (No)와 5번 (Length)이다.[m
[32m  +[m
[32m  +	for (int i = 0; i < (m_ListCtrl.GetItemCount()); i++) {[m
[32m  +		m_ListCtrl.SetItemData(i, i);[m
[32m  +	}[m
[32m  +[m
[32m  +	if (m_bAscending) {[m
[32m  +		m_bAscending = false;[m
[32m  +	}[m
[32m  +	else {[m
[32m  +		m_bAscending = true;[m
[32m  +	}[m
[32m  +[m
[32m  +	SORTPARAM sortparams;[m
[32m  +	sortparams.pList = &m_ListCtrl;[m
[32m  +	sortparams.iSrotColumn = nColumn;[m
[32m  +	sortparams.bSortDirect = m_bAscending;[m
[32m  +[m
[32m  +	if (nColumn == 0 || nColumn == 5) {[m
[32m  +		m_ListCtrl.SortItems(&SortFuncNum, (LPARAM)& sortparams);[m
[32m  +	}else {[m
[32m  +		m_ListCtrl.SortItems(&SortFuncStr, (LPARAM)& sortparams);[m
[32m  +	}[m
[32m  +[m
[32m  +	*pResult = 0;[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +int CALLBACK CMFCApplication1Dlg::SortFuncStr(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)[m
[32m  +{[m
[32m  +	CListCtrl* pList = ((SORTPARAM*)lParamSort)->pList;[m
[32m  +	int iSortColumn = ((SORTPARAM*)lParamSort)->iSrotColumn;[m
[32m  +	bool bSortDirect = ((SORTPARAM*)lParamSort)->bSortDirect;[m
[32m  +[m
[32m  +[m
[32m  +	LVFINDINFO info1, info2;[m
[32m  +	info1.flags = LVFI_PARAM;[m
[32m  +	info1.lParam = lParam1;[m
[32m  +	info2.flags = LVFI_PARAM;[m
[32m  +	info2.lParam = lParam2;[m
[32m  +[m
[32m  +	int irow1 = pList->FindItem(&info1, -1);[m
[32m  +	int irow2 = pList->FindItem(&info2, -1);[m
[32m  +[m
[32m  +	CString strItem1 = pList->GetItemText(irow1, iSortColumn);[m
[32m  +	CString strItem2 = pList->GetItemText(irow2, iSortColumn);[m
[32m  +[m
[32m  +	return bSortDirect ? strItem1.Compare(strItem2) : -strItem1.Compare(strItem2);[m
[32m  +}[m
[32m  +[m
[32m  +int CALLBACK CMFCApplication1Dlg::SortFuncNum(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)[m
[32m  +{[m
[32m  +	CListCtrl* pList = ((SORTPARAM*)lParamSort)->pList;[m
[32m  +	int iSortColumn = ((SORTPARAM*)lParamSort)->iSrotColumn;[m
[32m  +	bool bSortDirect = ((SORTPARAM*)lParamSort)->bSortDirect;[m
[32m  +[m
[32m  +[m
[32m  +	LVFINDINFO info1, info2;[m
[32m  +	info1.flags = LVFI_PARAM;[m
[32m  +	info1.lParam = lParam1;[m
[32m  +	info2.flags = LVFI_PARAM;[m
[32m  +	info2.lParam = lParam2;[m
[32m  +[m
[32m  +	int irow1 = pList->FindItem(&info1, -1);[m
[32m  +	int irow2 = pList->FindItem(&info2, -1);[m
[32m  +[m
[32m  +	int numItem1 = _ttoi(pList->GetItemText(irow1, iSortColumn));[m
[32m  +	int numItem2 = _ttoi(pList->GetItemText(irow2, iSortColumn));[m
[32m  +[m
[32m  +	return !bSortDirect ? numItem1 < numItem2 : numItem1 > numItem2;[m
[32m  +}[m
[32m  +[m
[32m  +BOOL CMFCApplication1Dlg::PreTranslateMessage(MSG* pMsg)[m
[32m  +{[m
[32m  +	// TODO: 여기에 특수화된 코드를 추가 및/또는 기본 클래스를 호출합니다.[m
[32m  +[m
[32m  +	if (pMsg->message == WM_KEYDOWN)[m
[32m  +	{[m
[32m  +		if (pMsg->wParam == VK_ESCAPE)[m
[32m  +			return TRUE;[m
[32m  +		else if (pMsg->wParam == VK_RETURN)[m
[32m  +			return TRUE;[m
[32m  +	}[m
[32m  +	return CDialogEx::PreTranslateMessage(pMsg);[m
[32m  +}[m
[32m+++[m
[32m+++CString CMFCApplication1Dlg::HexToDec(CString _number) {[m
[32m+++	if (_number == L"a" || _number == L"A") {[m
[32m+++		_number = L"10";[m
[32m+++	}else 	if (_number == L"b" || _number == L"B") {[m
[32m+++		_number = L"11";[m
[32m+++	}else 	if (_number == L"c" || _number == L"C") {[m
[32m+++		_number = L"12";[m
[32m+++	}else 	if (_number == L"d" || _number == L"D") {[m
[32m+++		_number = L"13";[m
[32m+++	}else 	if (_number == L"e" || _number == L"E") {[m
[32m+++		_number = L"14";[m
[32m+++	}else 	if (_number == L"f" || _number == L"F") {[m
[32m+++		_number = L"15";[m
[32m+++	}[m
[32m+++	else {[m
[32m+++		_number = _number;[m
[32m+++	}[m
[32m+++[m
[32m+++	return _number;[m
[32m+++}[m
[32m+++[m
[32m+++CString CMFCApplication1Dlg::HexToBinary(CString _number) {[m
[32m+++	CString result;[m
[32m+++	CString temp1;[m
[32m+++	CString temp2;[m
[32m+++	CString temp3;[m
[32m+++	CString temp4;[m
[32m+++[m
[32m+++	temp1 = CString((std::to_string(_ttoi(_number) % 2)).c_str());[m
[32m+++	_number = CString((std::to_string(_ttoi(_number) / 2)).c_str());[m
[32m+++	temp2 = CString((std::to_string(_ttoi(_number) % 2)).c_str());[m
[32m+++	_number = CString((std::to_string(_ttoi(_number) / 2)).c_str());[m
[32m+++	temp3 = CString((std::to_string(_ttoi(_number) % 2)).c_str());[m
[32m+++	temp4 = CString((std::to_string(_ttoi(_number) / 2)).c_str());[m
[32m+++[m
[32m+++	result = temp4 + temp3 + temp2 + temp1;[m
[32m+++[m
[32m+++	return result;[m
[32m+++}[m
[32m+++[m
[32m+++CString CMFCApplication1Dlg::GetTCPFlagToBin(CString _Flag) {[m
[32m+++	// 6비트 예약 6비트 TCP 플래그[m
[32m+++	/*[m
[32m+++	1. Urgent [m
[32m+++	2. Acknowledge[m
[32m+++	3. Push[m
[32m+++	4. Reset[m
[32m+++	5. Syn[m
[32m+++	6. Fin[m
[32m+++	*/[m
[32m+++	CString Result;[m
[32m+++	CString FirstByte = _Flag.Mid(0, 1);[m
[32m+++	CString SecondByte = _Flag.Mid(1, 1);[m
[32m+++	CString ThirdByte = _Flag.Mid(2, 1);[m
[32m+++[m
[32m+++	FirstByte = HexToDec(FirstByte);[m
[32m+++	SecondByte = HexToDec(SecondByte);[m
[32m+++	ThirdByte = HexToDec(ThirdByte);[m
[32m+++[m
[32m+++	FirstByte = HexToBinary(FirstByte);[m
[32m+++	SecondByte = HexToBinary(SecondByte);[m
[32m+++	ThirdByte = HexToBinary(ThirdByte);[m
[32m+++[m
[32m+++	Result = FirstByte + SecondByte + ThirdByte;[m
[32m+++[m
[32m+++	return Result;[m
[32m+++}[m
[32m+++[m
[32m+++CString CMFCApplication1Dlg::GetTCPFlagToStr(CString _Flag) {[m
[32m+++	// 6비트 예약 6비트 TCP 플래그[m
[32m+++	/*[m
[32m+++	1. Urgent[m
[32m+++	2. Acknowledge[m
[32m+++	3. Push[m
[32m+++	4. Reset[m
[32m+++	5. Syn[m
[32m+++	6. Fin[m
[32m+++	*/[m
[32m+++	CString Result;[m
[32m+++[m
[32m+++	CString Urgent = _Flag.Mid(0, 1);[m
[32m+++	CString Acknowledgment = _Flag.Mid(0, 1);[m
[32m+++	CString Push= _Flag.Mid(0, 1);[m
[32m+++	CString Reset = _Flag.Mid(0, 1);[m
[32m+++	CString Syn = _Flag.Mid(0, 1);[m
[32m+++	CString Fin = _Flag.Mid(0, 1);[m
[32m+++[m
[32m+++	if (Urgent == L"1") {[m
[32m+++		Result = "URG";[m
[32m+++	}[m
[32m+++	else if(Acknowledgment = L"1") {[m
[32m+++		if (Result.IsEmpty() == true) {[m
[32m+++			Result = "ACK";[m
[32m+++		}[m
[32m+++		else {[m
[32m+++			Result.Append(L", ACK");[m
[32m+++		}[m
[32m+++	}[m
[32m+++	else if (Push = L"1") {[m
[32m+++		if (Result.IsEmpty() == true) {[m
[32m+++			Result = "PUSH";[m
[32m+++		}[m
[32m+++		else {[m
[32m+++			Result.Append(L", PUSH");[m
[32m+++		}[m
[32m+++	}[m
[32m+++	else if (Reset = L"1") {[m
[32m+++		if (Result.IsEmpty() == true) {[m
[32m+++			Result = "RST";[m
[32m+++		}[m
[32m+++		else {[m
[32m+++			Result.Append(L", RST");[m
[32m+++		}[m
[32m+++	}[m
[32m+++	else if (Syn = L"1") {[m
[32m+++		if (Result.IsEmpty() == true) {[m
[32m+++			Result = "SYN";[m
[32m+++		}[m
[32m+++		else {[m
[32m+++			Result.Append(L", SYN");[m
[32m+++		}[m
[32m+++	}[m
[32m+++	else if (Fin = L"1") {[m
[32m+++		if (Result.IsEmpty() == true) {[m
[32m+++			Result = "FIN";[m
[32m+++		}[m
[32m+++		else {[m
[32m+++			Result.Append(L", FIN");[m
[32m+++		}[m
[32m+++	}[m
[32m+++[m
[32m+++	return Result;[m
[32m+++}[m
[32m+++[m
[32m+++[m
[32m+++CString CMFCApplication1Dlg::GetTCPFlagToLongStr(CString _Flag) {[m
[32m+++	// 6비트 예약 6비트 TCP 플래그[m
[32m+++	/*[m
[32m+++	1. Urgent[m
[32m+++	2. Acknowledge[m
[32m+++	3. Push[m
[32m+++	4. Reset[m
[32m+++	5. Syn[m
[32m+++	6. Fin[m
[32m+++	*/[m
[32m+++	CString Result = L"";[m
[32m+++	CString FlagArray[6] = { L"U",L"A",L"P",L"R",L"S",L"F" };[m
[32m+++[m
[32m+++	for (int i = 0; i < _Flag.GetLength(); i++) {[m
[32m+++		if (_Flag.Mid(i, 1) == L"1"&&i>5) {[m
[32m+++			Result.Append(FlagArray[i-6]);[m
[32m+++		}[m
[32m+++		else {[m
[32m+++			Result.Append(L". ");[m
[32m+++		}[m
[32m+++	}[m
[32m+++[m
[32m+++	return Result;[m
[32m+++}[m
[1mdiff --cc MFCApplication1/MFCApplication1Dlg.h[m
[1mindex a3c91dd,a3c91dd,0000000..c8c3a41[m
mode 100644,100644,000000..100644[m
[1m--- a/MFCApplication1/MFCApplication1Dlg.h[m
[1m+++ b/MFCApplication1/MFCApplication1Dlg.h[m
[36m@@@@ -1,151 -1,151 -1,0 +1,156 @@@@[m
[32m  +﻿[m
[32m  +// MFCApplication1Dlg.h: 헤더 파일[m
[32m  +//[m
[32m  +[m
[32m  +#pragma once[m
[32m  +#include "NetworkInterfaceDlg.h"[m
[32m  +[m
[32m  +typedef struct ip_address {[m
[32m  +	u_char byte1;[m
[32m  +	u_char byte2;[m
[32m  +	u_char byte3;[m
[32m  +	u_char byte4;[m
[32m  +}ip_address;[m
[32m  +[m
[32m  +typedef struct ip_header {[m
[32m  +	u_char ver_ihl; // Version (4 bits) + Internet header length (4 bits)  [m
[32m  +	u_char tos; // Type of service   [m
[32m  +	u_short tlen; // Total length   [m
[32m  +	u_short identification; // Identification  [m
[32m  +	u_short flags_fo; // Flags (3 bits) + Fragment offset (13 bits)  [m
[32m  +	u_char ttl; // Time to live  [m
[32m  +	u_char proto; // Protocol  [m
[32m  +	u_short crc; // Header checksum  [m
[32m  +	ip_address saddr; // Source address  [m
[32m  +	ip_address daddr; // Destination address  [m
[32m  +	u_int op_pad; // Option + Padding  [m
[32m  +}ip_header;[m
[32m  +[m
[32m  +typedef struct udp_header {[m
[32m  +	u_short sport;   // Source port  [m
[32m  +	u_short dport;   // Destination port  [m
[32m  +	u_short len;   // Datagram length  [m
[32m  +	u_short crc;   // Checksum  [m
[32m  +}udp_header;[m
[32m  +[m
[32m  +typedef struct ether_header {[m
[32m  +	u_char dst_host[6];[m
[32m  +	u_char src_host[6];[m
[32m  +	u_short frame_type;[m
[32m  +}ether_header;[m
[32m  +[m
[32m  +typedef struct tcp_header {[m
[32m  +	u_short sport; // Source port  [m
[32m  +	u_short dport; // Destination port  [m
[32m  +	u_int seqnum; // Sequence Number  [m
[32m  +	u_int acknum; // Acknowledgement number  [m
[32m  +	u_char hlen; // Header length  [m
[32m  +	u_char flags; // packet flags  [m
[32m  +	u_short win; // Window size  [m
[32m  +	u_short crc; // Header Checksum  [m
[32m  +	u_short urgptr; // Urgent pointer...still don't know what this is...  [m
[32m  +}tcp_header;[m
[32m  +[m
[32m  +typedef struct icmp_header {[m
[32m  +	u_char type;[m
[32m  +	u_char code;[m
[32m  +	u_short checksum;[m
[32m  +	u_short id;[m
[32m  +	u_short seq;[m
[32m  +}icmp_header;[m
[32m  +[m
[32m  +typedef struct arp_header {[m
[32m  +	u_short htype;    /* Hardware Type           */[m
[32m  +	u_short ptype;    /* Protocol Type           */[m
[32m  +	u_char hlen;        /* Hardware Address Length */[m
[32m  +	u_char plen;        /* Protocol Address Length */[m
[32m  +	u_short oper;     /* Operation Code          */[m
[32m  +	u_char sha[6];      /* Sender hardware address */[m
[32m  +	u_char spa[4];      /* Sender IP address       */[m
[32m  +	u_char tha[6];      /* Target hardware address */[m
[32m  +	u_char tpa[4];      /* Target IP address       */[m
[32m  +}arp_header;[m
[32m  +[m
[32m  +// CMFCApplication1Dlg 대화 상자[m
[32m  +class CMFCApplication1Dlg : public CDialogEx[m
[32m  +{[m
[32m  +// 생성입니다.[m
[32m  +public:[m
[32m  +	CMFCApplication1Dlg(CWnd* pParent = nullptr);	// 표준 생성자입니다.[m
[32m  +[m
[32m  +	enum ThreadWorking {[m
[32m  +		STOP = 0,[m
[32m  +		RUNNING = 1,[m
[32m  +		PAUSE = 2[m
[32m  +	};[m
[32m  +[m
[32m  +	bool m_bThreadStart = false;[m
[32m  +	CWinThread* m_pThread = NULL;[m
[32m  +	ThreadWorking m_ThreadWorkType = STOP;[m
[32m  +[m
[32m  +	static UINT ThreadFunctionFirstTest(LPVOID _mothod);[m
[32m  +[m
[32m  +// 대화 상자 데이터입니다.[m
[32m  +#ifdef AFX_DESIGN_TIME[m
[32m  +	enum { IDD = IDD_MFCAPPLICATION1_DIALOG };[m
[32m  +#endif[m
[32m  +[m
[32m  +	protected:[m
[32m  +	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV 지원입니다.[m
[32m  +[m
[32m  +[m
[32m  +// 구현입니다.[m
[32m  +protected:[m
[32m  +	HICON m_hIcon;[m
[32m  +[m
[32m  +	// 생성된 메시지 맵 함수[m
[32m  +	virtual BOOL OnInitDialog();[m
[32m  +	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);[m
[32m  +	afx_msg void OnPaint();[m
[32m  +	afx_msg HCURSOR OnQueryDragIcon();[m
[32m  +	DECLARE_MESSAGE_MAP()[m
[32m  +public:[m
[32m  +	int packet_cnt = 0;[m
[32m  +	int tcp_pkt_cnt = 0;[m
[32m  +	int udp_pkt_cnt = 0;[m
[32m  +	int arp_pkt_cnt = 0;[m
[32m  +	int icmp_pkt_cnt = 0;[m
[32m  +[m
[32m  +[m
[32m  +	NetworkInterfaceDlg netInterfaceDlg;[m
[32m  +	CString m_strSelectedNetworkInterface;[m
[32m  +[m
[32m  +	BOOL m_bAscending;[m
[32m  +[m
[32m  +	struct SORTPARAM[m
[32m  +	{[m
[32m  +		int iSrotColumn;[m
[32m  +		bool bSortDirect;[m
[32m  +		CListCtrl* pList;[m
[32m  +	};[m
[32m  +[m
[32m  +[m
[32m  +	CListCtrl m_ListCtrl;[m
[32m  +	afx_msg void OnBnClickedButton1();[m
[32m  +	CListBox m_HexEditorList;[m
[32m  +	afx_msg void OnBnClickedButton2();[m
[32m  +	afx_msg void OnBnClickedButton3();[m
[32m  +	CButton pause_button;[m
[32m  +	void CMFCApplication1Dlg::ChangeStaticText(int all_pkt_cnt, int tcp_pkt_cnt, int udp_pkt_cnt, int arp_pkt_cnt, int icmp_pkt_cnt);[m
[32m  +	void ClearPacketCnt();[m
[32m  +	CString GetIPAddr(ip_address ip_addr);[m
[32m  +	afx_msg void OnCustomdrawList(NMHDR* pNMHDR, LRESULT* pResult);[m
[32m  +	afx_msg void OnNMDblclkList2(NMHDR* pNMHDR, LRESULT* pResult);[m
[32m  +	CTreeCtrl PacketDataCtrl;[m
[32m  +	afx_msg void OnHdnItemclick(NMHDR* pNMHDR, LRESULT* Result);[m
[32m  +	static int CALLBACK SortFuncStr(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);[m
[32m  +	static int CALLBACK SortFuncNum(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);[m
[32m  +	CListCtrl PacketDumpList;[m
[32m  +	CEdit m_FilterEditCtrl;[m
[32m  +	virtual BOOL PreTranslateMessage(MSG* pMsg);[m
[32m+++	CString HexToDec(CString _number);[m
[32m+++	CString HexToBinary(CString _number);[m
[32m+++	CString GetTCPFlagToBin(CString _Flag);[m
[32m+++	CString GetTCPFlagToStr(CString _Flag);[m
[32m+++	CString GetTCPFlagToLongStr(CString _Flag);[m
[32m  +};[m
[1mdiff --cc MFCApplication1/NetworkInterfaceDlg.cpp[m
[1mindex 2f6b894,2f6b894,0000000..968a285[m
mode 100644,100644,000000..100644[m
[1m--- a/MFCApplication1/NetworkInterfaceDlg.cpp[m
[1m+++ b/MFCApplication1/NetworkInterfaceDlg.cpp[m
[36m@@@@ -1,251 -1,251 -1,0 +1,251 @@@@[m
[32m  +﻿// NetworkInterfaceDlg.cpp: 구현 파일[m
[32m  +//[m
[32m  +[m
[32m  +#include "pch.h"[m
[32m  +#include "MFCApplication1.h"[m
[32m  +#include "NetworkInterfaceDlg.h"[m
[32m  +#include "afxdialogex.h"[m
[32m  +[m
[32m  +#include "pcap.h"[m
[32m  +#include <string>[m
[32m  +[m
[32m  +// NetworkInterfaceDlg 대화 상자[m
[32m  +[m
[32m  +IMPLEMENT_DYNAMIC(NetworkInterfaceDlg, CDialogEx)[m
[32m  +[m
[32m  +NetworkInterfaceDlg::NetworkInterfaceDlg(CWnd* pParent /*=nullptr*/)[m
[32m  +	: CDialogEx(IDD_DIALOG1, pParent)[m
[32m  +{[m
[32m  +	m_hIcon = AfxGetApp()->LoadIcon(IDI_ICON1);[m
[32m  +}[m
[32m  +[m
[32m  +NetworkInterfaceDlg::~NetworkInterfaceDlg()[m
[32m  +{[m
[32m  +}[m
[32m  +[m
[32m  +void NetworkInterfaceDlg::DoDataExchange(CDataExchange* pDX)[m
[32m  +{[m
[32m  +	CDialogEx::DoDataExchange(pDX);[m
[32m  +	DDX_Control(pDX, IDC_LIST1, NetWorkListCtrl);[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +BEGIN_MESSAGE_MAP(NetworkInterfaceDlg, CDialogEx)[m
[32m  +	ON_BN_CLICKED(IDCANCEL, &NetworkInterfaceDlg::OnBnClickedCancel)[m
[32m  +	ON_BN_CLICKED(IDOK, &NetworkInterfaceDlg::OnBnClickedOk)[m
[32m  +	ON_NOTIFY(NM_CLICK, IDC_LIST1, &NetworkInterfaceDlg::OnNMClickList1)[m
[32m  +	ON_NOTIFY(HDN_ITEMCLICK, 0, &NetworkInterfaceDlg::OnHdnItemclickList1)[m
[32m  +END_MESSAGE_MAP()[m
[32m  +[m
[32m  +[m
[32m  +BOOL NetworkInterfaceDlg::OnInitDialog()[m
[32m  +{[m
[32m  +	CDialogEx::OnInitDialog();[m
[32m  +[m
[32m  +	SetIcon(m_hIcon, FALSE);			// 큰 아이콘을 설정합니다.[m
[32m  +	SetIcon(m_hIcon, TRUE);			// 큰 아이콘을 설정합니다.[m
[32m  +[m
[32m  +	// TODO:  여기에 추가 초기화 작업을 추가합니다.[m
[32m  +[m
[32m  +	SetWindowText(_T("Network Interface"));[m
[32m  +[m
[32m  +[m
[32m  +	CRect rt;[m
[32m  +	NetWorkListCtrl.GetWindowRect(&rt);[m
[32m  +	NetWorkListCtrl.SetExtendedStyle(LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT);[m
[32m  +	LV_COLUMN add_column;[m
[32m  +	// 컬럼 속성을 지정한다. 텍스트 형식을 사용하고 폭을 명시하겠다고 설정한다.[m
[32m  +[m
[32m  +	add_column.mask = LVCF_TEXT | LVCF_WIDTH;[m
[32m  +	add_column.pszText = L"No";[m
[32m  +	add_column.cx = rt.Width() * 0.1;[m
[32m  +	NetWorkListCtrl.InsertColumn(0, &add_column);[m
[32m  +[m
[32m  +	// Description[m
[32m  +	add_column.pszText = L"Network Interface";[m
[32m  +	add_column.cx = rt.Width() * 0.89;[m
[32m  +	NetWorkListCtrl.InsertColumn(1, &add_column);[m
[32m  +[m
[32m  +	// name[m
[32m  +	add_column.pszText = L"Network Interface";[m
[32m  +	add_column.cx = rt.Width() * 0;[m
[32m  +	NetWorkListCtrl.InsertColumn(2, &add_column);[m
[32m  +[m
[32m  +[m
[32m  +	pcap_if_t* alldevs;[m
[32m  +	pcap_if_t* d;[m
[32m  +	int i = 0;[m
[32m  +	pcap_t* adhandle;[m
[32m  +	char errbuf[PCAP_ERRBUF_SIZE];[m
[32m  +[m
[32m  +	if (pcap_findalldevs(&alldevs, errbuf) == -1) {[m
[32m  +		fprintf(stderr, "Error in pcap_findalldevs: %s\n", errbuf);[m
[32m  +		MessageBox(L"오류", L"다시시도 해주세요");[m
[32m  +	}[m
[32m  +[m
[32m  +	for (d = alldevs; d; d = d->next) {[m
[32m  +		int column_count = NetWorkListCtrl.GetItemCount();[m
[32m  +[m
[32m  +		CString column_count_str;[m
[32m  +		column_count_str.Format(_T("%d"), column_count + 1);[m
[32m  +		NetWorkListCtrl.InsertItem(column_count, column_count_str);[m
[32m  +[m
[32m  +		InterfaceDescription = ((LPSTR)d->description);[m
[32m  +		InterfaceName = ((LPSTR)d->name);[m
[32m  +		// netInterfaceStr += ((LPSTR)d->name);[m
[32m  +[m
[32m  +		NetWorkListCtrl.SetItem(column_count, 1, LVIF_TEXT, InterfaceDescription, NULL, NULL, NULL, NULL);[m
[32m  +		NetWorkListCtrl.SetItem(column_count, 2, LVIF_TEXT, InterfaceName, NULL, NULL, NULL, NULL);[m
[32m  +	}[m
[32m  +[m
[32m  +[m
[32m  +	return TRUE;  // return TRUE unless you set the focus to a control[m
[32m  +				  // 예외: OCX 속성 페이지는 FALSE를 반환해야 합니다.[m
[32m  +}[m
[32m  +[m
[32m  +// NetworkInterfaceDlg 메시지 처리기[m
[32m  +[m
[32m  +[m
[32m  +void NetworkInterfaceDlg::OnBnClickedCancel()[m
[32m  +{[m
[32m  +	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.[m
[32m  +[m
[32m  +	this->CancelButtonClicked = true;[m
[32m  +[m
[32m  +[m
[32m  +	CDialogEx::OnCancel();[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +bool NetworkInterfaceDlg::CancelButtonClickedFunction(void) {[m
[32m  +	return CancelButtonClicked;[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +void NetworkInterfaceDlg::OnBnClickedOk()[m
[32m  +{[m
[32m  +	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.[m
[32m  +	 //value[m
[32m  +[m
[32m  +	m_strSelectedValue = NetWorkListCtrl.GetItemText(m_nSelectedIndex, 1);[m
[32m  +	InterfaceDescription = m_strSelectedValue;[m
[32m  +[m
[32m  +	m_strSelectedValue = NetWorkListCtrl.GetItemText(m_nSelectedIndex, 2);[m
[32m  +	InterfaceName = m_strSelectedValue;[m
[32m  +[m
[32m  +	if (m_nSelectedIndex == -123) {[m
[32m  +		MessageBox(L"인터페이스를 선택해주세요.", L"오류");[m
[32m  +	}[m
[32m  +	else {[m
[32m  +		CDialogEx::OnOK();[m
[32m  +	}[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +void NetworkInterfaceDlg::OnNMClickList1(NMHDR* pNMHDR, LRESULT* pResult)[m
[32m  +{[m
[32m  +	LPNMITEMACTIVATE pNMItemActivate = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);[m
[32m  +	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.[m
[32m  +	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;[m
[32m  +	m_nSelectedIndex = pNMListView->iItem;//[m
[32m  +[m
[32m  +[m
[32m  +	//int idx = pNMListView -> iItem;// 선택된 아이템값의 아이템을 (0,1 ... n 번째 인덱스) 한개 가져온다.[m
[32m  +	//CString sIndexValue;sIndexValue = m_listDataTable.GetItemText(idx, 1);[m
[32m  +	*pResult = 0;[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +void NetworkInterfaceDlg::OnHdnItemclickList1(NMHDR* pNMHDR, LRESULT* pResult)[m
[32m  +{[m
[32m  +	// TODO: 여기에 컨트롤 알림 처리기 코드를 추가합니다.[m
[32m  +[m
[32m  +	LPNMHEADER pNMLV = reinterpret_cast<LPNMHEADER>(pNMHDR);[m
[32m  +[m
[32m  +	int nColumn = pNMLV->iItem;[m
[32m  +	// 선택된 헤더 숫자로 정렬해야되는 값은 0번 (No)와 5번 (Length)이다.[m
[32m  +[m
[32m  +	for (int i = 0; i < (NetWorkListCtrl.GetItemCount()); i++) {[m
[32m  +		NetWorkListCtrl.SetItemData(i, i);[m
[32m  +	}[m
[32m  +/*[m
[32m  +	if (m_bAscending) {[m
[32m  +		m_bAscending = false;[m
[32m  +	}[m
[32m  +	else {[m
[32m  +		m_bAscending = true;[m
[32m  +	}[m
[32m  +[m
[32m  +	SORTPARAM sortparams;[m
[32m  +	sortparams.pList = &NetWorkListCtrl;[m
[32m  +	sortparams.iSrotColumn = nColumn;[m
[32m  +	sortparams.bSortDirect = m_bAscending;[m
[32m  +[m
[32m  +	if (nColumn == 0 || nColumn == 5) {[m
[32m  +		NetWorkListCtrl.SortItems(&SortFuncNum, (LPARAM)& sortparams);[m
[32m  +	}[m
[32m  +	else {[m
[32m  +		NetWorkListCtrl.SortItems(&SortFuncStr, (LPARAM)& sortparams);[m
[32m  +	}*/[m
[32m  +	*pResult = 0;[m
[32m  +}[m
[32m  +[m
[32m  +[m
[32m  +[m
[32m  +int CALLBACK NetworkInterfaceDlg::SortFuncStr(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)[m
[32m  +{[m
[32m  +	CListCtrl* pList = ((SORTPARAM*)lParamSort)->pList;[m
[32m  +	int iSortColumn = ((SORTPARAM*)lParamSort)->iSrotColumn;[m
[32m  +	bool bSortDirect = ((SORTPARAM*)lParamSort)->bSortDirect;[m
[32m  +[m
[32m  +[m
[32m  +	LVFINDINFO info1, info2;[m
[32m  +	info1.flags = LVFI_PARAM;[m
[32m  +	info1.lParam = lParam1;[m
[32m  +	info2.flags = LVFI_PARAM;[m
[32m  +	info2.lParam = lParam2;[m
[32m  +[m
[32m  +	int irow1 = pList->FindItem(&info1, -1);[m
[32m  +	int irow2 = pList->FindItem(&info2, -1);[m
[32m  +[m
[32m  +	CString strItem1 = pList->GetItemText(irow1, iSortColumn);[m
[32m  +	CString strItem2 = pList->GetItemText(irow2, iSortColumn);[m
[32m  +[m
[32m  +	return bSortDirect ? strItem1.Compare(strItem2) : -strItem1.Compare(strItem2);[m
[32m  +}[m
[32m  +[m
[32m  +int CALLBACK NetworkInterfaceDlg::SortFuncNum(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)[m
[32m  +{[m
[32m  +	CListCtrl* pList = ((SORTPARAM*)lParamSort)->pList;[m
[32m  +	int iSortColumn = ((SORTPARAM*)lParamSort)->iSrotColumn;[m
[32m  +	bool bSortDirect = ((SORTPARAM*)lParamSort)->bSortDirect;[m
[32m  +[m
[32m  +[m
[32m  +	LVFINDINFO info1, info2;[m
[32m  +	info1.flags = LVFI_PARAM;[m
[32m  +	info1.lParam = lParam1;[m
[32m  +	info2.flags = LVFI_PARAM;[m
[32m  +	info2.lParam = lParam2;[m
[32m  +[m
[32m  +	int irow1 = pList->FindItem(&info1, -1);[m
[32m  +	int irow2 = pList->FindItem(&info2, -1);[m
[32m  +[m
[32m  +	int numItem1 = _ttoi(pList->GetItemText(irow1, iSortColumn));[m
[32m  +	int numItem2 = _ttoi(pList->GetItemText(irow2, iSortColumn));[m
[32m  +[m
[32m  +	return !bSortDirect ? numItem1 < numItem2 : numItem1 > numItem2;[m
[32m  +}[m
[32m  +[m
[32m  +BOOL NetworkInterfaceDlg::PreTranslateMessage(MSG* pMsg)[m
[32m  +{[m
[32m  +	// TODO: 여기에 특수화된 코드를 추가 및/또는 기본 클래스를 호출합니다.[m
[32m  +[m
[32m  +	if (pMsg->message == WM_KEYDOWN)[m
[32m  +	{[m
[32m  +		if (pMsg->wParam == VK_ESCAPE)[m
[32m  +			return TRUE;[m
[32m  +		else if (pMsg->wParam == VK_RETURN)[m
[32m  +			return TRUE;[m
[32m  +	}[m
[32m  +	return CDialogEx::PreTranslateMessage(pMsg);[m
[31m-- }[m
[32m+++}[m
